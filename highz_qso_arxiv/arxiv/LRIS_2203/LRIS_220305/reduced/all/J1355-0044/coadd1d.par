# PypeIt reduction rules.
[rdx]
    # Spectrograph that provided the data to be reduced.  See
    # :ref:`instruments` for valid options.
    spectrograph = keck_lris_red_mark4
    # Restrict reduction to a list of detector indices. In case of
    # mosaic reduction (currently only available for Gemini/GMOS and
    # Keck/DEIMOS) ``detnum`` should be a list of tuples of the detector
    # indices that are mosaiced together. E.g., for Gemini/GMOS
    # ``detnum`` would be ``[(1,2,3)]`` and for KEck/DEIMOS it would be
    # ``[(1, 5), (2, 6), (3, 7), (4, 8)]`` This cannot (and should not)
    # be used with slitspatnum.
    detnum = None
    # A filename given to output the details of the sorted files.  If
    # None, the default is the root name of the pypeit file.  If off, no
    # output is produced.
    sortroot = None
    # The window of time in hours to search for calibration frames for a
    # science frame
    calwin = 0
    # Directory relative to calling directory to write science files.
    scidir = Science
    # Directory relative to calling directory to write quality
    # assessment files.
    qadir = QA
    # Path to folder for performing reductions.  Default is the current
    # working directory.
    redux_path = /Volumes/Extreme SSD/highz_qso_arxiv/highz_qso_arxiv/arxiv/LRIS_2203/LRIS_220305/reduced/all_redo/J1355-0044
    # Ignore bad headers (NOT recommended unless you know it is safe).
    ignore_bad_headers = False
    # Restrict reduction to a set of slit DET:SPAT values (closest slit
    # is used). Example syntax -- slitspatnum = 1:175,1:205   If you are
    # re-running the code, (i.e. modifying one slit) you *must* have the
    # precise SPAT_ID index.This cannot (and should not) be used with
    # detnum
    slitspatnum = None
    # Restrict reduction to a set of slitmask IDsExample syntax --
    # maskIDs = 818006,818015 This must be used with detnum (for now).
    maskIDs = None
# Parameters for the calibration algorithms
[calibrations]
    # If provided, it should be the name of the folder to write master
    # files. NOT A PATH.
    master_dir = Masters
    # If masters='force', this is the setup name to be used: e.g.,
    # C_02_aa .  The detector number is ignored but the other
    # information must match the Master Frames in the master frame
    # folder.
    setup = None
    # Make a bad pixel mask from bias frames? Bias frames must be
    # provided.
    bpm_usebias = False
    # Raise an error if the calibration check fails
    raise_chk_error = True
    # The frames and combination rules for the bias correction
    [[biasframe]]
        # Frame type.  Options are: align, arc, bias, dark, pinhole,
        # pixelflat, illumflat, science, standard, trace, tilt, sky
        frametype = bias
        # A master calibrations file to use if it exists.
        useframe = None
        # Used in identifying frames of this type.  This sets the
        # minimum and maximum allowed exposure times.  There must be two
        # items in the list.  Use None to indicate no limit; i.e., to
        # select exposures with any time greater than 30 sec, use exprng
        # = [30, None].
        exprng = None, 1
        # Low level parameters used for basic image processing
        [[[process]]]
            # Trim the image to the detector supplied region
            trim = True
            # Convert the ADUs to electrons using the detector gain
            apply_gain = True
            # Orient the raw image into the PypeIt frame
            orient = True
            # Method used to fit the overscan. Options are: polynomial,
            # savgol, median
            overscan_method = savgol
            # Parameters for the overscan subtraction.  For
            # 'polynomial', set overcan_par = order, number of pixels,
            # number of repeats ; for 'savgol', set overscan_par =
            # order, window size ; for 'median', set overscan_par = None
            # or omit the keyword.
            overscan_par = 5, 65
            # Method used to combine multiple frames.  Options are:
            # median, mean
            combine = median
            # Handling of saturated pixels.  Options are: reject, force,
            # nothing
            satpix = reject
            # Identify CRs and mask them
            mask_cr = False
            # Perform sigma clipping when combining.  Only used with
            # combine=mean
            clip = True
            # Number of pixels to reject at the lowest and highest ends
            # of the distribution; i.e., n_lohi = low, high.  Use None
            # for no limit.
            n_lohi = 0, 0
            # Maximum number of iterations for LA cosmics routine.
            lamaxiter = 1
            # Factor by which to expand regions with cosmic rays
            # detected by the LA cosmics routine.
            grow = 1.5
            # Sigma-clipping level for when clip=True; Use None for
            # automatic limit (recommended).
            comb_sigrej = None
            # Remove compact detections in LA cosmics routine
            rmcompact = True
            # Sigma level for rejection in LA cosmics routine
            sigclip = 4.5
            # Fraction for the lower clipping threshold in LA cosmics
            # routine.
            sigfrac = 0.3
            # Object detection limit in LA cosmics routine
            objlim = 3.0
            # Use a bias image.  If True, one or more must be supplied
            # in the PypeIt file.
            use_biasimage = False
            # Subtract off the overscan.  Detector *must* have one or
            # code will crash.
            use_overscan = True
            # Subtract off a dark image.  If True, one or more darks
            # must be provided.
            use_darkimage = False
            # If designated dark frames are used and have a different
            # exposure time than the science frames, scale the counts by
            # the by the ratio in the exposure times to adjust the dark
            # counts for the difference in exposure time.  WARNING: You
            # should always take dark frames that have the same exposure
            # time as your science frames, so use this option with care!
            dark_expscale = False
            # If True, use the standard deviation in the overscan region
            # to measure an empirical readnoise to use in the noise
            # model.
            empirical_rn = False
            # Use the bias- and dark-subtracted image to calculate and
            # include electron count shot noise in the image processing
            # error budget
            shot_noise = False
            # Impose a noise floor by adding the provided fraction of
            # the bias- and dark-subtracted electron counts to the error
            # budget.  E.g., a value of 0.01 means that the S/N of the
            # counts in the image will never be greater than 100.
            noise_floor = 0.0
            # Use the pixel flat to make pixel-level corrections.  A
            # pixelflat image must be provied.
            use_pixelflat = False
            # Use the illumination flat to correct for the illumination
            # profile of each slit.
            use_illumflat = False
            # Use the relative spectral illumination profiles to correct
            # the spectral illumination profile of each slit. This is
            # primarily used for IFUs.  To use this, you must set
            # ``slit_illum_relative=True`` in the ``flatfield``
            # parameter set!
            use_specillum = False
            # Subtract off a detector pattern. This pattern is assumed
            # to be sinusoidal along one direction, with a frequency
            # that is constant across the detector.
            use_pattern = False
            # Subtract off the continuum level from an image. This
            # parameter should only be set to True to combine arcs with
            # multiple different lamps.For all other cases, this
            # parameter should probably be False.
            use_continuum = False
            # Correct slits, illumination flat, etc. for flexure
            spat_flexure_correct = False
    # The frames and combination rules for the dark-current correction
    [[darkframe]]
        # Frame type.  Options are: align, arc, bias, dark, pinhole,
        # pixelflat, illumflat, science, standard, trace, tilt, sky
        frametype = dark
        # A master calibrations file to use if it exists.
        useframe = None
        # Used in identifying frames of this type.  This sets the
        # minimum and maximum allowed exposure times.  There must be two
        # items in the list.  Use None to indicate no limit; i.e., to
        # select exposures with any time greater than 30 sec, use exprng
        # = [30, None].
        exprng = 999999, None
        # Low level parameters used for basic image processing
        [[[process]]]
            # Trim the image to the detector supplied region
            trim = True
            # Convert the ADUs to electrons using the detector gain
            apply_gain = True
            # Orient the raw image into the PypeIt frame
            orient = True
            # Method used to fit the overscan. Options are: polynomial,
            # savgol, median
            overscan_method = savgol
            # Parameters for the overscan subtraction.  For
            # 'polynomial', set overcan_par = order, number of pixels,
            # number of repeats ; for 'savgol', set overscan_par =
            # order, window size ; for 'median', set overscan_par = None
            # or omit the keyword.
            overscan_par = 5, 65
            # Method used to combine multiple frames.  Options are:
            # median, mean
            combine = mean
            # Handling of saturated pixels.  Options are: reject, force,
            # nothing
            satpix = reject
            # Identify CRs and mask them
            mask_cr = True
            # Perform sigma clipping when combining.  Only used with
            # combine=mean
            clip = True
            # Number of pixels to reject at the lowest and highest ends
            # of the distribution; i.e., n_lohi = low, high.  Use None
            # for no limit.
            n_lohi = 0, 0
            # Maximum number of iterations for LA cosmics routine.
            lamaxiter = 1
            # Factor by which to expand regions with cosmic rays
            # detected by the LA cosmics routine.
            grow = 1.5
            # Sigma-clipping level for when clip=True; Use None for
            # automatic limit (recommended).
            comb_sigrej = None
            # Remove compact detections in LA cosmics routine
            rmcompact = True
            # Sigma level for rejection in LA cosmics routine
            sigclip = 4.5
            # Fraction for the lower clipping threshold in LA cosmics
            # routine.
            sigfrac = 0.3
            # Object detection limit in LA cosmics routine
            objlim = 3.0
            # Use a bias image.  If True, one or more must be supplied
            # in the PypeIt file.
            use_biasimage = True
            # Subtract off the overscan.  Detector *must* have one or
            # code will crash.
            use_overscan = True
            # Subtract off a dark image.  If True, one or more darks
            # must be provided.
            use_darkimage = False
            # If designated dark frames are used and have a different
            # exposure time than the science frames, scale the counts by
            # the by the ratio in the exposure times to adjust the dark
            # counts for the difference in exposure time.  WARNING: You
            # should always take dark frames that have the same exposure
            # time as your science frames, so use this option with care!
            dark_expscale = False
            # If True, use the standard deviation in the overscan region
            # to measure an empirical readnoise to use in the noise
            # model.
            empirical_rn = False
            # Use the bias- and dark-subtracted image to calculate and
            # include electron count shot noise in the image processing
            # error budget
            shot_noise = True
            # Impose a noise floor by adding the provided fraction of
            # the bias- and dark-subtracted electron counts to the error
            # budget.  E.g., a value of 0.01 means that the S/N of the
            # counts in the image will never be greater than 100.
            noise_floor = 0.0
            # Use the pixel flat to make pixel-level corrections.  A
            # pixelflat image must be provied.
            use_pixelflat = False
            # Use the illumination flat to correct for the illumination
            # profile of each slit.
            use_illumflat = False
            # Use the relative spectral illumination profiles to correct
            # the spectral illumination profile of each slit. This is
            # primarily used for IFUs.  To use this, you must set
            # ``slit_illum_relative=True`` in the ``flatfield``
            # parameter set!
            use_specillum = False
            # Subtract off a detector pattern. This pattern is assumed
            # to be sinusoidal along one direction, with a frequency
            # that is constant across the detector.
            use_pattern = False
            # Subtract off the continuum level from an image. This
            # parameter should only be set to True to combine arcs with
            # multiple different lamps.For all other cases, this
            # parameter should probably be False.
            use_continuum = False
            # Correct slits, illumination flat, etc. for flexure
            spat_flexure_correct = False
    # The frames and combination rules for the wavelength calibration
    [[arcframe]]
        # Frame type.  Options are: align, arc, bias, dark, pinhole,
        # pixelflat, illumflat, science, standard, trace, tilt, sky
        frametype = arc
        # A master calibrations file to use if it exists.
        useframe = None
        # Used in identifying frames of this type.  This sets the
        # minimum and maximum allowed exposure times.  There must be two
        # items in the list.  Use None to indicate no limit; i.e., to
        # select exposures with any time greater than 30 sec, use exprng
        # = [30, None].
        exprng = None, None
        # Low level parameters used for basic image processing
        [[[process]]]
            # Trim the image to the detector supplied region
            trim = True
            # Convert the ADUs to electrons using the detector gain
            apply_gain = True
            # Orient the raw image into the PypeIt frame
            orient = True
            # Method used to fit the overscan. Options are: polynomial,
            # savgol, median
            overscan_method = savgol
            # Parameters for the overscan subtraction.  For
            # 'polynomial', set overcan_par = order, number of pixels,
            # number of repeats ; for 'savgol', set overscan_par =
            # order, window size ; for 'median', set overscan_par = None
            # or omit the keyword.
            overscan_par = 5, 65
            # Method used to combine multiple frames.  Options are:
            # median, mean
            combine = mean
            # Handling of saturated pixels.  Options are: reject, force,
            # nothing
            satpix = reject
            # Identify CRs and mask them
            mask_cr = False
            # Perform sigma clipping when combining.  Only used with
            # combine=mean
            clip = True
            # Number of pixels to reject at the lowest and highest ends
            # of the distribution; i.e., n_lohi = low, high.  Use None
            # for no limit.
            n_lohi = 0, 0
            # Maximum number of iterations for LA cosmics routine.
            lamaxiter = 1
            # Factor by which to expand regions with cosmic rays
            # detected by the LA cosmics routine.
            grow = 1.5
            # Sigma-clipping level for when clip=True; Use None for
            # automatic limit (recommended).
            comb_sigrej = None
            # Remove compact detections in LA cosmics routine
            rmcompact = True
            # Sigma level for rejection in LA cosmics routine
            sigclip = 4.5
            # Fraction for the lower clipping threshold in LA cosmics
            # routine.
            sigfrac = 0.3
            # Object detection limit in LA cosmics routine
            objlim = 3.0
            # Use a bias image.  If True, one or more must be supplied
            # in the PypeIt file.
            use_biasimage = True
            # Subtract off the overscan.  Detector *must* have one or
            # code will crash.
            use_overscan = True
            # Subtract off a dark image.  If True, one or more darks
            # must be provided.
            use_darkimage = False
            # If designated dark frames are used and have a different
            # exposure time than the science frames, scale the counts by
            # the by the ratio in the exposure times to adjust the dark
            # counts for the difference in exposure time.  WARNING: You
            # should always take dark frames that have the same exposure
            # time as your science frames, so use this option with care!
            dark_expscale = False
            # If True, use the standard deviation in the overscan region
            # to measure an empirical readnoise to use in the noise
            # model.
            empirical_rn = False
            # Use the bias- and dark-subtracted image to calculate and
            # include electron count shot noise in the image processing
            # error budget
            shot_noise = True
            # Impose a noise floor by adding the provided fraction of
            # the bias- and dark-subtracted electron counts to the error
            # budget.  E.g., a value of 0.01 means that the S/N of the
            # counts in the image will never be greater than 100.
            noise_floor = 0.0
            # Use the pixel flat to make pixel-level corrections.  A
            # pixelflat image must be provied.
            use_pixelflat = False
            # Use the illumination flat to correct for the illumination
            # profile of each slit.
            use_illumflat = False
            # Use the relative spectral illumination profiles to correct
            # the spectral illumination profile of each slit. This is
            # primarily used for IFUs.  To use this, you must set
            # ``slit_illum_relative=True`` in the ``flatfield``
            # parameter set!
            use_specillum = False
            # Subtract off a detector pattern. This pattern is assumed
            # to be sinusoidal along one direction, with a frequency
            # that is constant across the detector.
            use_pattern = False
            # Subtract off the continuum level from an image. This
            # parameter should only be set to True to combine arcs with
            # multiple different lamps.For all other cases, this
            # parameter should probably be False.
            use_continuum = False
            # Correct slits, illumination flat, etc. for flexure
            spat_flexure_correct = False
    # The frames and combination rules for the wavelength tilts
    [[tiltframe]]
        # Frame type.  Options are: align, arc, bias, dark, pinhole,
        # pixelflat, illumflat, science, standard, trace, tilt, sky
        frametype = tilt
        # A master calibrations file to use if it exists.
        useframe = None
        # Used in identifying frames of this type.  This sets the
        # minimum and maximum allowed exposure times.  There must be two
        # items in the list.  Use None to indicate no limit; i.e., to
        # select exposures with any time greater than 30 sec, use exprng
        # = [30, None].
        exprng = None, None
        # Low level parameters used for basic image processing
        [[[process]]]
            # Trim the image to the detector supplied region
            trim = True
            # Convert the ADUs to electrons using the detector gain
            apply_gain = True
            # Orient the raw image into the PypeIt frame
            orient = True
            # Method used to fit the overscan. Options are: polynomial,
            # savgol, median
            overscan_method = savgol
            # Parameters for the overscan subtraction.  For
            # 'polynomial', set overcan_par = order, number of pixels,
            # number of repeats ; for 'savgol', set overscan_par =
            # order, window size ; for 'median', set overscan_par = None
            # or omit the keyword.
            overscan_par = 5, 65
            # Method used to combine multiple frames.  Options are:
            # median, mean
            combine = mean
            # Handling of saturated pixels.  Options are: reject, force,
            # nothing
            satpix = reject
            # Identify CRs and mask them
            mask_cr = False
            # Perform sigma clipping when combining.  Only used with
            # combine=mean
            clip = True
            # Number of pixels to reject at the lowest and highest ends
            # of the distribution; i.e., n_lohi = low, high.  Use None
            # for no limit.
            n_lohi = 0, 0
            # Maximum number of iterations for LA cosmics routine.
            lamaxiter = 1
            # Factor by which to expand regions with cosmic rays
            # detected by the LA cosmics routine.
            grow = 1.5
            # Sigma-clipping level for when clip=True; Use None for
            # automatic limit (recommended).
            comb_sigrej = None
            # Remove compact detections in LA cosmics routine
            rmcompact = True
            # Sigma level for rejection in LA cosmics routine
            sigclip = 4.5
            # Fraction for the lower clipping threshold in LA cosmics
            # routine.
            sigfrac = 0.3
            # Object detection limit in LA cosmics routine
            objlim = 3.0
            # Use a bias image.  If True, one or more must be supplied
            # in the PypeIt file.
            use_biasimage = True
            # Subtract off the overscan.  Detector *must* have one or
            # code will crash.
            use_overscan = True
            # Subtract off a dark image.  If True, one or more darks
            # must be provided.
            use_darkimage = False
            # If designated dark frames are used and have a different
            # exposure time than the science frames, scale the counts by
            # the by the ratio in the exposure times to adjust the dark
            # counts for the difference in exposure time.  WARNING: You
            # should always take dark frames that have the same exposure
            # time as your science frames, so use this option with care!
            dark_expscale = False
            # If True, use the standard deviation in the overscan region
            # to measure an empirical readnoise to use in the noise
            # model.
            empirical_rn = False
            # Use the bias- and dark-subtracted image to calculate and
            # include electron count shot noise in the image processing
            # error budget
            shot_noise = True
            # Impose a noise floor by adding the provided fraction of
            # the bias- and dark-subtracted electron counts to the error
            # budget.  E.g., a value of 0.01 means that the S/N of the
            # counts in the image will never be greater than 100.
            noise_floor = 0.0
            # Use the pixel flat to make pixel-level corrections.  A
            # pixelflat image must be provied.
            use_pixelflat = False
            # Use the illumination flat to correct for the illumination
            # profile of each slit.
            use_illumflat = False
            # Use the relative spectral illumination profiles to correct
            # the spectral illumination profile of each slit. This is
            # primarily used for IFUs.  To use this, you must set
            # ``slit_illum_relative=True`` in the ``flatfield``
            # parameter set!
            use_specillum = False
            # Subtract off a detector pattern. This pattern is assumed
            # to be sinusoidal along one direction, with a frequency
            # that is constant across the detector.
            use_pattern = False
            # Subtract off the continuum level from an image. This
            # parameter should only be set to True to combine arcs with
            # multiple different lamps.For all other cases, this
            # parameter should probably be False.
            use_continuum = False
            # Correct slits, illumination flat, etc. for flexure
            spat_flexure_correct = False
    # The frames and combination rules for the pixel flat
    [[pixelflatframe]]
        # Frame type.  Options are: align, arc, bias, dark, pinhole,
        # pixelflat, illumflat, science, standard, trace, tilt, sky
        frametype = pixelflat
        # A master calibrations file to use if it exists.
        useframe = None
        # Used in identifying frames of this type.  This sets the
        # minimum and maximum allowed exposure times.  There must be two
        # items in the list.  Use None to indicate no limit; i.e., to
        # select exposures with any time greater than 30 sec, use exprng
        # = [30, None].
        exprng = None, 60
        # Low level parameters used for basic image processing
        [[[process]]]
            # Trim the image to the detector supplied region
            trim = True
            # Convert the ADUs to electrons using the detector gain
            apply_gain = True
            # Orient the raw image into the PypeIt frame
            orient = True
            # Method used to fit the overscan. Options are: polynomial,
            # savgol, median
            overscan_method = savgol
            # Parameters for the overscan subtraction.  For
            # 'polynomial', set overcan_par = order, number of pixels,
            # number of repeats ; for 'savgol', set overscan_par =
            # order, window size ; for 'median', set overscan_par = None
            # or omit the keyword.
            overscan_par = 5, 65
            # Method used to combine multiple frames.  Options are:
            # median, mean
            combine = mean
            # Handling of saturated pixels.  Options are: reject, force,
            # nothing
            satpix = nothing
            # Identify CRs and mask them
            mask_cr = False
            # Perform sigma clipping when combining.  Only used with
            # combine=mean
            clip = True
            # Number of pixels to reject at the lowest and highest ends
            # of the distribution; i.e., n_lohi = low, high.  Use None
            # for no limit.
            n_lohi = 0, 0
            # Maximum number of iterations for LA cosmics routine.
            lamaxiter = 1
            # Factor by which to expand regions with cosmic rays
            # detected by the LA cosmics routine.
            grow = 1.5
            # Sigma-clipping level for when clip=True; Use None for
            # automatic limit (recommended).
            comb_sigrej = None
            # Remove compact detections in LA cosmics routine
            rmcompact = True
            # Sigma level for rejection in LA cosmics routine
            sigclip = 4.5
            # Fraction for the lower clipping threshold in LA cosmics
            # routine.
            sigfrac = 0.3
            # Object detection limit in LA cosmics routine
            objlim = 3.0
            # Use a bias image.  If True, one or more must be supplied
            # in the PypeIt file.
            use_biasimage = True
            # Subtract off the overscan.  Detector *must* have one or
            # code will crash.
            use_overscan = True
            # Subtract off a dark image.  If True, one or more darks
            # must be provided.
            use_darkimage = False
            # If designated dark frames are used and have a different
            # exposure time than the science frames, scale the counts by
            # the by the ratio in the exposure times to adjust the dark
            # counts for the difference in exposure time.  WARNING: You
            # should always take dark frames that have the same exposure
            # time as your science frames, so use this option with care!
            dark_expscale = False
            # If True, use the standard deviation in the overscan region
            # to measure an empirical readnoise to use in the noise
            # model.
            empirical_rn = False
            # Use the bias- and dark-subtracted image to calculate and
            # include electron count shot noise in the image processing
            # error budget
            shot_noise = True
            # Impose a noise floor by adding the provided fraction of
            # the bias- and dark-subtracted electron counts to the error
            # budget.  E.g., a value of 0.01 means that the S/N of the
            # counts in the image will never be greater than 100.
            noise_floor = 0.0
            # Use the pixel flat to make pixel-level corrections.  A
            # pixelflat image must be provied.
            use_pixelflat = False
            # Use the illumination flat to correct for the illumination
            # profile of each slit.
            use_illumflat = False
            # Use the relative spectral illumination profiles to correct
            # the spectral illumination profile of each slit. This is
            # primarily used for IFUs.  To use this, you must set
            # ``slit_illum_relative=True`` in the ``flatfield``
            # parameter set!
            use_specillum = False
            # Subtract off a detector pattern. This pattern is assumed
            # to be sinusoidal along one direction, with a frequency
            # that is constant across the detector.
            use_pattern = False
            # Subtract off the continuum level from an image. This
            # parameter should only be set to True to combine arcs with
            # multiple different lamps.For all other cases, this
            # parameter should probably be False.
            use_continuum = False
            # Correct slits, illumination flat, etc. for flexure
            spat_flexure_correct = False
    # The frames and combination rules for the pinholes
    [[pinholeframe]]
        # Frame type.  Options are: align, arc, bias, dark, pinhole,
        # pixelflat, illumflat, science, standard, trace, tilt, sky
        frametype = pinhole
        # A master calibrations file to use if it exists.
        useframe = None
        # Used in identifying frames of this type.  This sets the
        # minimum and maximum allowed exposure times.  There must be two
        # items in the list.  Use None to indicate no limit; i.e., to
        # select exposures with any time greater than 30 sec, use exprng
        # = [30, None].
        exprng = 999999, None
        # Low level parameters used for basic image processing
        [[[process]]]
            # Trim the image to the detector supplied region
            trim = True
            # Convert the ADUs to electrons using the detector gain
            apply_gain = True
            # Orient the raw image into the PypeIt frame
            orient = True
            # Method used to fit the overscan. Options are: polynomial,
            # savgol, median
            overscan_method = savgol
            # Parameters for the overscan subtraction.  For
            # 'polynomial', set overcan_par = order, number of pixels,
            # number of repeats ; for 'savgol', set overscan_par =
            # order, window size ; for 'median', set overscan_par = None
            # or omit the keyword.
            overscan_par = 5, 65
            # Method used to combine multiple frames.  Options are:
            # median, mean
            combine = mean
            # Handling of saturated pixels.  Options are: reject, force,
            # nothing
            satpix = reject
            # Identify CRs and mask them
            mask_cr = False
            # Perform sigma clipping when combining.  Only used with
            # combine=mean
            clip = True
            # Number of pixels to reject at the lowest and highest ends
            # of the distribution; i.e., n_lohi = low, high.  Use None
            # for no limit.
            n_lohi = 0, 0
            # Maximum number of iterations for LA cosmics routine.
            lamaxiter = 1
            # Factor by which to expand regions with cosmic rays
            # detected by the LA cosmics routine.
            grow = 1.5
            # Sigma-clipping level for when clip=True; Use None for
            # automatic limit (recommended).
            comb_sigrej = None
            # Remove compact detections in LA cosmics routine
            rmcompact = True
            # Sigma level for rejection in LA cosmics routine
            sigclip = 4.5
            # Fraction for the lower clipping threshold in LA cosmics
            # routine.
            sigfrac = 0.3
            # Object detection limit in LA cosmics routine
            objlim = 3.0
            # Use a bias image.  If True, one or more must be supplied
            # in the PypeIt file.
            use_biasimage = True
            # Subtract off the overscan.  Detector *must* have one or
            # code will crash.
            use_overscan = True
            # Subtract off a dark image.  If True, one or more darks
            # must be provided.
            use_darkimage = False
            # If designated dark frames are used and have a different
            # exposure time than the science frames, scale the counts by
            # the by the ratio in the exposure times to adjust the dark
            # counts for the difference in exposure time.  WARNING: You
            # should always take dark frames that have the same exposure
            # time as your science frames, so use this option with care!
            dark_expscale = False
            # If True, use the standard deviation in the overscan region
            # to measure an empirical readnoise to use in the noise
            # model.
            empirical_rn = False
            # Use the bias- and dark-subtracted image to calculate and
            # include electron count shot noise in the image processing
            # error budget
            shot_noise = True
            # Impose a noise floor by adding the provided fraction of
            # the bias- and dark-subtracted electron counts to the error
            # budget.  E.g., a value of 0.01 means that the S/N of the
            # counts in the image will never be greater than 100.
            noise_floor = 0.0
            # Use the pixel flat to make pixel-level corrections.  A
            # pixelflat image must be provied.
            use_pixelflat = True
            # Use the illumination flat to correct for the illumination
            # profile of each slit.
            use_illumflat = True
            # Use the relative spectral illumination profiles to correct
            # the spectral illumination profile of each slit. This is
            # primarily used for IFUs.  To use this, you must set
            # ``slit_illum_relative=True`` in the ``flatfield``
            # parameter set!
            use_specillum = False
            # Subtract off a detector pattern. This pattern is assumed
            # to be sinusoidal along one direction, with a frequency
            # that is constant across the detector.
            use_pattern = False
            # Subtract off the continuum level from an image. This
            # parameter should only be set to True to combine arcs with
            # multiple different lamps.For all other cases, this
            # parameter should probably be False.
            use_continuum = False
            # Correct slits, illumination flat, etc. for flexure
            spat_flexure_correct = False
    # The frames and combination rules for the align frames
    [[alignframe]]
        # Frame type.  Options are: align, arc, bias, dark, pinhole,
        # pixelflat, illumflat, science, standard, trace, tilt, sky
        frametype = align
        # A master calibrations file to use if it exists.
        useframe = None
        # Used in identifying frames of this type.  This sets the
        # minimum and maximum allowed exposure times.  There must be two
        # items in the list.  Use None to indicate no limit; i.e., to
        # select exposures with any time greater than 30 sec, use exprng
        # = [30, None].
        exprng = None, None
        # Low level parameters used for basic image processing
        [[[process]]]
            # Trim the image to the detector supplied region
            trim = True
            # Convert the ADUs to electrons using the detector gain
            apply_gain = True
            # Orient the raw image into the PypeIt frame
            orient = True
            # Method used to fit the overscan. Options are: polynomial,
            # savgol, median
            overscan_method = savgol
            # Parameters for the overscan subtraction.  For
            # 'polynomial', set overcan_par = order, number of pixels,
            # number of repeats ; for 'savgol', set overscan_par =
            # order, window size ; for 'median', set overscan_par = None
            # or omit the keyword.
            overscan_par = 5, 65
            # Method used to combine multiple frames.  Options are:
            # median, mean
            combine = mean
            # Handling of saturated pixels.  Options are: reject, force,
            # nothing
            satpix = nothing
            # Identify CRs and mask them
            mask_cr = False
            # Perform sigma clipping when combining.  Only used with
            # combine=mean
            clip = True
            # Number of pixels to reject at the lowest and highest ends
            # of the distribution; i.e., n_lohi = low, high.  Use None
            # for no limit.
            n_lohi = 0, 0
            # Maximum number of iterations for LA cosmics routine.
            lamaxiter = 1
            # Factor by which to expand regions with cosmic rays
            # detected by the LA cosmics routine.
            grow = 1.5
            # Sigma-clipping level for when clip=True; Use None for
            # automatic limit (recommended).
            comb_sigrej = None
            # Remove compact detections in LA cosmics routine
            rmcompact = True
            # Sigma level for rejection in LA cosmics routine
            sigclip = 4.5
            # Fraction for the lower clipping threshold in LA cosmics
            # routine.
            sigfrac = 0.3
            # Object detection limit in LA cosmics routine
            objlim = 3.0
            # Use a bias image.  If True, one or more must be supplied
            # in the PypeIt file.
            use_biasimage = True
            # Subtract off the overscan.  Detector *must* have one or
            # code will crash.
            use_overscan = True
            # Subtract off a dark image.  If True, one or more darks
            # must be provided.
            use_darkimage = False
            # If designated dark frames are used and have a different
            # exposure time than the science frames, scale the counts by
            # the by the ratio in the exposure times to adjust the dark
            # counts for the difference in exposure time.  WARNING: You
            # should always take dark frames that have the same exposure
            # time as your science frames, so use this option with care!
            dark_expscale = False
            # If True, use the standard deviation in the overscan region
            # to measure an empirical readnoise to use in the noise
            # model.
            empirical_rn = False
            # Use the bias- and dark-subtracted image to calculate and
            # include electron count shot noise in the image processing
            # error budget
            shot_noise = True
            # Impose a noise floor by adding the provided fraction of
            # the bias- and dark-subtracted electron counts to the error
            # budget.  E.g., a value of 0.01 means that the S/N of the
            # counts in the image will never be greater than 100.
            noise_floor = 0.0
            # Use the pixel flat to make pixel-level corrections.  A
            # pixelflat image must be provied.
            use_pixelflat = False
            # Use the illumination flat to correct for the illumination
            # profile of each slit.
            use_illumflat = False
            # Use the relative spectral illumination profiles to correct
            # the spectral illumination profile of each slit. This is
            # primarily used for IFUs.  To use this, you must set
            # ``slit_illum_relative=True`` in the ``flatfield``
            # parameter set!
            use_specillum = False
            # Subtract off a detector pattern. This pattern is assumed
            # to be sinusoidal along one direction, with a frequency
            # that is constant across the detector.
            use_pattern = False
            # Subtract off the continuum level from an image. This
            # parameter should only be set to True to combine arcs with
            # multiple different lamps.For all other cases, this
            # parameter should probably be False.
            use_continuum = False
            # Correct slits, illumination flat, etc. for flexure
            spat_flexure_correct = False
    # Define the procedure for the alignment of traces
    [[alignment]]
        # Locations of the bars, in a list, specified as a fraction of
        # the slit width
        locations = 0.0, 0.5, 1.0
        # Order of the polynomial to use when fitting the trace of a
        # single bar
        trace_npoly = 4
        # Trim the slit by this number of pixels left/right before
        # finding alignment bars
        trim_edge = 0, 0
        # S/N ratio threshold for finding an alignment trace. This
        # should be a lownumber to ensure that the algorithm finds all
        # bars. The algorithm willthen only use the N most significant
        # detections, where N is the numberof elements specified in the
        # "locations" keyword argument
        snr_thresh = 1.0
    # The frames and combination rules for images used for slit tracing
    [[traceframe]]
        # Frame type.  Options are: align, arc, bias, dark, pinhole,
        # pixelflat, illumflat, science, standard, trace, tilt, sky
        frametype = trace
        # A master calibrations file to use if it exists.
        useframe = None
        # Used in identifying frames of this type.  This sets the
        # minimum and maximum allowed exposure times.  There must be two
        # items in the list.  Use None to indicate no limit; i.e., to
        # select exposures with any time greater than 30 sec, use exprng
        # = [30, None].
        exprng = None, 60
        # Low level parameters used for basic image processing
        [[[process]]]
            # Trim the image to the detector supplied region
            trim = True
            # Convert the ADUs to electrons using the detector gain
            apply_gain = True
            # Orient the raw image into the PypeIt frame
            orient = True
            # Method used to fit the overscan. Options are: polynomial,
            # savgol, median
            overscan_method = savgol
            # Parameters for the overscan subtraction.  For
            # 'polynomial', set overcan_par = order, number of pixels,
            # number of repeats ; for 'savgol', set overscan_par =
            # order, window size ; for 'median', set overscan_par = None
            # or omit the keyword.
            overscan_par = 5, 65
            # Method used to combine multiple frames.  Options are:
            # median, mean
            combine = mean
            # Handling of saturated pixels.  Options are: reject, force,
            # nothing
            satpix = reject
            # Identify CRs and mask them
            mask_cr = False
            # Perform sigma clipping when combining.  Only used with
            # combine=mean
            clip = True
            # Number of pixels to reject at the lowest and highest ends
            # of the distribution; i.e., n_lohi = low, high.  Use None
            # for no limit.
            n_lohi = 0, 0
            # Maximum number of iterations for LA cosmics routine.
            lamaxiter = 1
            # Factor by which to expand regions with cosmic rays
            # detected by the LA cosmics routine.
            grow = 1.5
            # Sigma-clipping level for when clip=True; Use None for
            # automatic limit (recommended).
            comb_sigrej = None
            # Remove compact detections in LA cosmics routine
            rmcompact = True
            # Sigma level for rejection in LA cosmics routine
            sigclip = 4.5
            # Fraction for the lower clipping threshold in LA cosmics
            # routine.
            sigfrac = 0.3
            # Object detection limit in LA cosmics routine
            objlim = 3.0
            # Use a bias image.  If True, one or more must be supplied
            # in the PypeIt file.
            use_biasimage = True
            # Subtract off the overscan.  Detector *must* have one or
            # code will crash.
            use_overscan = True
            # Subtract off a dark image.  If True, one or more darks
            # must be provided.
            use_darkimage = False
            # If designated dark frames are used and have a different
            # exposure time than the science frames, scale the counts by
            # the by the ratio in the exposure times to adjust the dark
            # counts for the difference in exposure time.  WARNING: You
            # should always take dark frames that have the same exposure
            # time as your science frames, so use this option with care!
            dark_expscale = False
            # If True, use the standard deviation in the overscan region
            # to measure an empirical readnoise to use in the noise
            # model.
            empirical_rn = False
            # Use the bias- and dark-subtracted image to calculate and
            # include electron count shot noise in the image processing
            # error budget
            shot_noise = True
            # Impose a noise floor by adding the provided fraction of
            # the bias- and dark-subtracted electron counts to the error
            # budget.  E.g., a value of 0.01 means that the S/N of the
            # counts in the image will never be greater than 100.
            noise_floor = 0.0
            # Use the pixel flat to make pixel-level corrections.  A
            # pixelflat image must be provied.
            use_pixelflat = False
            # Use the illumination flat to correct for the illumination
            # profile of each slit.
            use_illumflat = False
            # Use the relative spectral illumination profiles to correct
            # the spectral illumination profile of each slit. This is
            # primarily used for IFUs.  To use this, you must set
            # ``slit_illum_relative=True`` in the ``flatfield``
            # parameter set!
            use_specillum = False
            # Subtract off a detector pattern. This pattern is assumed
            # to be sinusoidal along one direction, with a frequency
            # that is constant across the detector.
            use_pattern = False
            # Subtract off the continuum level from an image. This
            # parameter should only be set to True to combine arcs with
            # multiple different lamps.For all other cases, this
            # parameter should probably be False.
            use_continuum = False
            # Correct slits, illumination flat, etc. for flexure
            spat_flexure_correct = False
    # The frames and combination rules for the illumination flat
    [[illumflatframe]]
        # Frame type.  Options are: align, arc, bias, dark, pinhole,
        # pixelflat, illumflat, science, standard, trace, tilt, sky
        frametype = illumflat
        # A master calibrations file to use if it exists.
        useframe = None
        # Used in identifying frames of this type.  This sets the
        # minimum and maximum allowed exposure times.  There must be two
        # items in the list.  Use None to indicate no limit; i.e., to
        # select exposures with any time greater than 30 sec, use exprng
        # = [30, None].
        exprng = None, None
        # Low level parameters used for basic image processing
        [[[process]]]
            # Trim the image to the detector supplied region
            trim = True
            # Convert the ADUs to electrons using the detector gain
            apply_gain = True
            # Orient the raw image into the PypeIt frame
            orient = True
            # Method used to fit the overscan. Options are: polynomial,
            # savgol, median
            overscan_method = savgol
            # Parameters for the overscan subtraction.  For
            # 'polynomial', set overcan_par = order, number of pixels,
            # number of repeats ; for 'savgol', set overscan_par =
            # order, window size ; for 'median', set overscan_par = None
            # or omit the keyword.
            overscan_par = 5, 65
            # Method used to combine multiple frames.  Options are:
            # median, mean
            combine = mean
            # Handling of saturated pixels.  Options are: reject, force,
            # nothing
            satpix = nothing
            # Identify CRs and mask them
            mask_cr = False
            # Perform sigma clipping when combining.  Only used with
            # combine=mean
            clip = True
            # Number of pixels to reject at the lowest and highest ends
            # of the distribution; i.e., n_lohi = low, high.  Use None
            # for no limit.
            n_lohi = 0, 0
            # Maximum number of iterations for LA cosmics routine.
            lamaxiter = 1
            # Factor by which to expand regions with cosmic rays
            # detected by the LA cosmics routine.
            grow = 1.5
            # Sigma-clipping level for when clip=True; Use None for
            # automatic limit (recommended).
            comb_sigrej = None
            # Remove compact detections in LA cosmics routine
            rmcompact = True
            # Sigma level for rejection in LA cosmics routine
            sigclip = 4.5
            # Fraction for the lower clipping threshold in LA cosmics
            # routine.
            sigfrac = 0.3
            # Object detection limit in LA cosmics routine
            objlim = 3.0
            # Use a bias image.  If True, one or more must be supplied
            # in the PypeIt file.
            use_biasimage = True
            # Subtract off the overscan.  Detector *must* have one or
            # code will crash.
            use_overscan = True
            # Subtract off a dark image.  If True, one or more darks
            # must be provided.
            use_darkimage = False
            # If designated dark frames are used and have a different
            # exposure time than the science frames, scale the counts by
            # the by the ratio in the exposure times to adjust the dark
            # counts for the difference in exposure time.  WARNING: You
            # should always take dark frames that have the same exposure
            # time as your science frames, so use this option with care!
            dark_expscale = False
            # If True, use the standard deviation in the overscan region
            # to measure an empirical readnoise to use in the noise
            # model.
            empirical_rn = False
            # Use the bias- and dark-subtracted image to calculate and
            # include electron count shot noise in the image processing
            # error budget
            shot_noise = True
            # Impose a noise floor by adding the provided fraction of
            # the bias- and dark-subtracted electron counts to the error
            # budget.  E.g., a value of 0.01 means that the S/N of the
            # counts in the image will never be greater than 100.
            noise_floor = 0.0
            # Use the pixel flat to make pixel-level corrections.  A
            # pixelflat image must be provied.
            use_pixelflat = False
            # Use the illumination flat to correct for the illumination
            # profile of each slit.
            use_illumflat = False
            # Use the relative spectral illumination profiles to correct
            # the spectral illumination profile of each slit. This is
            # primarily used for IFUs.  To use this, you must set
            # ``slit_illum_relative=True`` in the ``flatfield``
            # parameter set!
            use_specillum = False
            # Subtract off a detector pattern. This pattern is assumed
            # to be sinusoidal along one direction, with a frequency
            # that is constant across the detector.
            use_pattern = False
            # Subtract off the continuum level from an image. This
            # parameter should only be set to True to combine arcs with
            # multiple different lamps.For all other cases, this
            # parameter should probably be False.
            use_continuum = False
            # Correct slits, illumination flat, etc. for flexure
            spat_flexure_correct = False
    # The frames and combination rules for the sky background
    # observations
    [[skyframe]]
        # Frame type.  Options are: align, arc, bias, dark, pinhole,
        # pixelflat, illumflat, science, standard, trace, tilt, sky
        frametype = sky
        # A master calibrations file to use if it exists.
        useframe = None
        # Used in identifying frames of this type.  This sets the
        # minimum and maximum allowed exposure times.  There must be two
        # items in the list.  Use None to indicate no limit; i.e., to
        # select exposures with any time greater than 30 sec, use exprng
        # = [30, None].
        exprng = None, None
        # Low level parameters used for basic image processing
        [[[process]]]
            # Trim the image to the detector supplied region
            trim = True
            # Convert the ADUs to electrons using the detector gain
            apply_gain = True
            # Orient the raw image into the PypeIt frame
            orient = True
            # Method used to fit the overscan. Options are: polynomial,
            # savgol, median
            overscan_method = savgol
            # Parameters for the overscan subtraction.  For
            # 'polynomial', set overcan_par = order, number of pixels,
            # number of repeats ; for 'savgol', set overscan_par =
            # order, window size ; for 'median', set overscan_par = None
            # or omit the keyword.
            overscan_par = 5, 65
            # Method used to combine multiple frames.  Options are:
            # median, mean
            combine = mean
            # Handling of saturated pixels.  Options are: reject, force,
            # nothing
            satpix = reject
            # Identify CRs and mask them
            mask_cr = True
            # Perform sigma clipping when combining.  Only used with
            # combine=mean
            clip = True
            # Number of pixels to reject at the lowest and highest ends
            # of the distribution; i.e., n_lohi = low, high.  Use None
            # for no limit.
            n_lohi = 0, 0
            # Maximum number of iterations for LA cosmics routine.
            lamaxiter = 1
            # Factor by which to expand regions with cosmic rays
            # detected by the LA cosmics routine.
            grow = 1.5
            # Sigma-clipping level for when clip=True; Use None for
            # automatic limit (recommended).
            comb_sigrej = None
            # Remove compact detections in LA cosmics routine
            rmcompact = True
            # Sigma level for rejection in LA cosmics routine
            sigclip = 4.5
            # Fraction for the lower clipping threshold in LA cosmics
            # routine.
            sigfrac = 0.3
            # Object detection limit in LA cosmics routine
            objlim = 3.0
            # Use a bias image.  If True, one or more must be supplied
            # in the PypeIt file.
            use_biasimage = True
            # Subtract off the overscan.  Detector *must* have one or
            # code will crash.
            use_overscan = True
            # Subtract off a dark image.  If True, one or more darks
            # must be provided.
            use_darkimage = False
            # If designated dark frames are used and have a different
            # exposure time than the science frames, scale the counts by
            # the by the ratio in the exposure times to adjust the dark
            # counts for the difference in exposure time.  WARNING: You
            # should always take dark frames that have the same exposure
            # time as your science frames, so use this option with care!
            dark_expscale = False
            # If True, use the standard deviation in the overscan region
            # to measure an empirical readnoise to use in the noise
            # model.
            empirical_rn = False
            # Use the bias- and dark-subtracted image to calculate and
            # include electron count shot noise in the image processing
            # error budget
            shot_noise = True
            # Impose a noise floor by adding the provided fraction of
            # the bias- and dark-subtracted electron counts to the error
            # budget.  E.g., a value of 0.01 means that the S/N of the
            # counts in the image will never be greater than 100.
            noise_floor = 0.01
            # Use the pixel flat to make pixel-level corrections.  A
            # pixelflat image must be provied.
            use_pixelflat = True
            # Use the illumination flat to correct for the illumination
            # profile of each slit.
            use_illumflat = True
            # Use the relative spectral illumination profiles to correct
            # the spectral illumination profile of each slit. This is
            # primarily used for IFUs.  To use this, you must set
            # ``slit_illum_relative=True`` in the ``flatfield``
            # parameter set!
            use_specillum = False
            # Subtract off a detector pattern. This pattern is assumed
            # to be sinusoidal along one direction, with a frequency
            # that is constant across the detector.
            use_pattern = False
            # Subtract off the continuum level from an image. This
            # parameter should only be set to True to combine arcs with
            # multiple different lamps.For all other cases, this
            # parameter should probably be False.
            use_continuum = False
            # Correct slits, illumination flat, etc. for flexure
            spat_flexure_correct = False
    # The frames and combination rules for the spectrophotometric
    # standard observations
    [[standardframe]]
        # Frame type.  Options are: align, arc, bias, dark, pinhole,
        # pixelflat, illumflat, science, standard, trace, tilt, sky
        frametype = standard
        # A master calibrations file to use if it exists.
        useframe = None
        # Used in identifying frames of this type.  This sets the
        # minimum and maximum allowed exposure times.  There must be two
        # items in the list.  Use None to indicate no limit; i.e., to
        # select exposures with any time greater than 30 sec, use exprng
        # = [30, None].
        exprng = None, 30
        # Low level parameters used for basic image processing
        [[[process]]]
            # Trim the image to the detector supplied region
            trim = True
            # Convert the ADUs to electrons using the detector gain
            apply_gain = True
            # Orient the raw image into the PypeIt frame
            orient = True
            # Method used to fit the overscan. Options are: polynomial,
            # savgol, median
            overscan_method = savgol
            # Parameters for the overscan subtraction.  For
            # 'polynomial', set overcan_par = order, number of pixels,
            # number of repeats ; for 'savgol', set overscan_par =
            # order, window size ; for 'median', set overscan_par = None
            # or omit the keyword.
            overscan_par = 5, 65
            # Method used to combine multiple frames.  Options are:
            # median, mean
            combine = mean
            # Handling of saturated pixels.  Options are: reject, force,
            # nothing
            satpix = reject
            # Identify CRs and mask them
            mask_cr = True
            # Perform sigma clipping when combining.  Only used with
            # combine=mean
            clip = True
            # Number of pixels to reject at the lowest and highest ends
            # of the distribution; i.e., n_lohi = low, high.  Use None
            # for no limit.
            n_lohi = 0, 0
            # Maximum number of iterations for LA cosmics routine.
            lamaxiter = 1
            # Factor by which to expand regions with cosmic rays
            # detected by the LA cosmics routine.
            grow = 1.5
            # Sigma-clipping level for when clip=True; Use None for
            # automatic limit (recommended).
            comb_sigrej = None
            # Remove compact detections in LA cosmics routine
            rmcompact = True
            # Sigma level for rejection in LA cosmics routine
            sigclip = 4.5
            # Fraction for the lower clipping threshold in LA cosmics
            # routine.
            sigfrac = 0.3
            # Object detection limit in LA cosmics routine
            objlim = 3.0
            # Use a bias image.  If True, one or more must be supplied
            # in the PypeIt file.
            use_biasimage = True
            # Subtract off the overscan.  Detector *must* have one or
            # code will crash.
            use_overscan = True
            # Subtract off a dark image.  If True, one or more darks
            # must be provided.
            use_darkimage = False
            # If designated dark frames are used and have a different
            # exposure time than the science frames, scale the counts by
            # the by the ratio in the exposure times to adjust the dark
            # counts for the difference in exposure time.  WARNING: You
            # should always take dark frames that have the same exposure
            # time as your science frames, so use this option with care!
            dark_expscale = False
            # If True, use the standard deviation in the overscan region
            # to measure an empirical readnoise to use in the noise
            # model.
            empirical_rn = False
            # Use the bias- and dark-subtracted image to calculate and
            # include electron count shot noise in the image processing
            # error budget
            shot_noise = True
            # Impose a noise floor by adding the provided fraction of
            # the bias- and dark-subtracted electron counts to the error
            # budget.  E.g., a value of 0.01 means that the S/N of the
            # counts in the image will never be greater than 100.
            noise_floor = 0.01
            # Use the pixel flat to make pixel-level corrections.  A
            # pixelflat image must be provied.
            use_pixelflat = True
            # Use the illumination flat to correct for the illumination
            # profile of each slit.
            use_illumflat = True
            # Use the relative spectral illumination profiles to correct
            # the spectral illumination profile of each slit. This is
            # primarily used for IFUs.  To use this, you must set
            # ``slit_illum_relative=True`` in the ``flatfield``
            # parameter set!
            use_specillum = False
            # Subtract off a detector pattern. This pattern is assumed
            # to be sinusoidal along one direction, with a frequency
            # that is constant across the detector.
            use_pattern = False
            # Subtract off the continuum level from an image. This
            # parameter should only be set to True to combine arcs with
            # multiple different lamps.For all other cases, this
            # parameter should probably be False.
            use_continuum = False
            # Correct slits, illumination flat, etc. for flexure
            spat_flexure_correct = True
    # Parameters used to set the flat-field procedure
    [[flatfield]]
        # Method used to flat field the data; use skip to skip flat-
        # fielding.  Options are: None, bspline, skip
        method = bspline
        # Filename of the image to use for pixel-level field flattening
        pixelflat_file = None
        # bspline break point spacing in units of pixels for spectral
        # fit to flat field blaze function.
        spec_samp_fine = 1.2
        # bspline break point spacing in units of pixels for 2-d
        # bspline-polynomial fit to flat field image residuals. This
        # should be a large number unless you are trying to fit a sky
        # flat with lots of narrow spectral features.
        spec_samp_coarse = 50.0
        # Spatial sampling for slit illumination function. This is the
        # width of the median filter in pixels used to determine the
        # slit illumination function, and thus sets the minimum scale on
        # which the illumination function will have features.
        spat_samp = 5.0
        # Use the illumination flat field to tweak the slit edges. This
        # will work even if illumflatten is set to False
        tweak_slits = True
        # If tweak_slits is True, this sets the illumination function
        # threshold used to tweak the slit boundaries based on the
        # illumination flat. It should be a number less than 1.0
        tweak_slits_thresh = 0.93
        # If tweak_slit is True, this sets the maximum fractional amount
        # (of a slits width) allowed for trimming each (i.e. left and
        # right) slit boundary, i.e. the default is 10% which means
        # slits would shrink or grow by at most 20% (10% on each side)
        tweak_slits_maxfrac = 0.1
        # Propagate the rejected pixels through the stages of the flat-
        # field fitting (i.e, from the spectral fit, to the spatial fit,
        # and finally to the 2D residual fit).  If False, pixels
        # rejected in each stage are included in each subsequent stage.
        rej_sticky = False
        # The number of pixels to trim each side of the slit when
        # selecting pixels to use for fitting the spectral response
        # function.  Single values are used for both slit edges; a two-
        # tuple can be used to trim the left and right sides
        # differently.
        slit_trim = 3.0
        # The number of pixels to pad the slit edges when constructing
        # the slit-illumination profile. Single value applied to both
        # edges.
        slit_illum_pad = 5.0
        # The number of rejection iterations to perform when
        # constructing the slit-illumination profile.  No rejection
        # iterations are performed if 0.  WARNING: Functionality still
        # being tested.
        illum_iter = 0
        # The sigma threshold used in the rejection iterations used to
        # refine the slit-illumination profile.  Rejection iterations
        # are only performed if ``illum_iter > 0``.
        illum_rej = 5.0
        # Order of polynomial used in the 2D bspline-polynomial fit to
        # flat-field image residuals. The code determines the order of
        # these polynomials to each slit automatically depending on the
        # slit width, which is why the default is None. Alter this
        # paramter at your own risk!
        twod_fit_npoly = None
        # Behavior when a slit is encountered with a large fraction of
        # saturated pixels in the flat-field.  The options are: 'crash'
        # - Raise an error and halt the data reduction; 'mask' - Mask
        # the slit, meaning no science data will be extracted from the
        # slit; 'continue' - ignore the flat-field correction, but
        # continue with the reduction.
        saturated_slits = crash
        # Generate an image of the relative spectral illumination for a
        # multi-slit setup.  If you set ``use_slitillum = True`` for any
        # of the frames that use the flatfield model, this *must* be set
        # to True. Currently, this is only used for IFU reductions.
        slit_illum_relative = False
        # The index of a reference slit (0-indexed) used for estimating
        # the relative spectral sensitivity (or the relative blaze).
        # This parameter is only used if ``slit_illum_relative = True``.
        slit_illum_ref_idx = 0
        # The number of pixels used to determine smoothly varying
        # relative weights is given by ``nspec/slit_illum_smooth_npix``,
        # where nspec is the number of spectral pixels.
        slit_illum_smooth_npix = 10
        # All values of the normalized pixel flat are set to 1 for
        # wavelengths below this value.
        pixelflat_min_wave = None
        # All values of the normalized pixel flat are set to 1 for
        # wavelengths above this value.
        pixelflat_max_wave = None
    # Parameters used to derive the wavelength solution
    [[wavelengths]]
        # Perform wavelength calibration with an arc, sky frame.  Use
        # 'pixel' for no wavelength solution.
        reference = arc
        # Method to use to fit the individual arc lines.  Note that some
        # of the available methods should not be used; they are unstable
        # and require significant parameter tweaking to succeed.  You
        # should use one of 'holy-grail', 'reidentify', or
        # 'full_template'.  'holy-grail' attempts to get a first guess
        # at line IDs by looking for patterns in the line locations.  It
        # is fully automated.  When it works, it works well; however, it
        # can fail catastrophically.  Instead, 'reidentify' and
        # 'full_template' are the preferred methods.  They require an
        # archived wavelength solution for your specific
        # instrument/grating combination as a reference.  This is used
        # to anchor the wavelength solution for the data being reduced.
        # All options are: simple, holy-grail, identify, reidentify,
        # full_template.
        method = holy-grail
        # Is this an echelle spectrograph? If yes an additional 2-d fit
        # wavelength fit will be performed as a function of spectral
        # pixel and order number to improve the wavelength solution
        echelle = False
        # Is this a fixed format echelle?  If so reidentification will
        # assume that each order in the data is aligned with a single
        # order in the reid arxiv.
        ech_fix_format = True
        # For echelle spectrographs, this is the order of the final 2d
        # fit to the spectral dimension.  You should choose this to be
        # the n_final of the fits to the individual orders.
        ech_nspec_coeff = 4
        # For echelle spectrographs, this is the order of the final 2d
        # fit to the order dimension.
        ech_norder_coeff = 4
        # For echelle spectrographs, this is the sigma-clipping
        # rejection threshold in the 2d fit to spectral and order
        # dimensions
        ech_sigrej = 2.0
        # Name of one or more ions used for the wavelength calibration.
        # Use ``None`` for no calibration. Choose ``use_header`` to use
        # the list of lamps recorded in the header of the arc frames
        # (this is currently available only for Keck DEIMOS and LDT
        # DeVeny).
        lamps = NeI, ArI, CdI, KrI, XeI, ZnI, HgI
        # Sigma threshold above fluctuations for arc-line detection.
        # Arcs are continuum subtracted and the fluctuations are
        # computed after continuum subtraction.  This can be a single
        # number or a vector (list or numpy array) that provides the
        # detection threshold for each slit.
        sigdetect = 10.0
        # Spectral sampling of the arc lines. This is the FWHM of an
        # arcline in *unbinned* pixels.
        fwhm = 4.0
        # Estimate spectral resolution in each slit using the arc lines.
        # If True, the estimated FWHM will override ``fwhm`` only in the
        # determination of the wavelength solution (i.e. not in
        # WaveTilts).
        fwhm_fromlines = False
        # Name of the archival wavelength solution file that will be
        # used for the wavelength reidentification.  Only used if
        # ``method`` is 'reidentify' or 'full_template'.
        reid_arxiv = None
        # Minimum number of times that a given candidate reidentified
        # line must be properly matched with a line in the arxiv to be
        # considered a good reidentification. If there is a lot of
        # duplication in the arxiv of the spectra in question (i.e.
        # multislit) set this to a number like 1-4. For echelle this
        # depends on the number of solutions in the arxiv.  Set this to
        # 1 for fixed format echelle spectrographs.  For an echelle with
        # a tiltable grating, this will depend on the number of
        # solutions in the arxiv.
        nreid_min = 1
        # Threshold for the *global* cross-correlation coefficient
        # between an input spectrum and member of the archive required
        # to attempt reidentification.  Spectra from the archive with a
        # lower cross-correlation are not used for reidentification.
        # This can be a single number or a list/array providing the
        # value for each slit.
        cc_thresh = 0.7
        # Threshold for the *local* cross-correlation coefficient,
        # evaluated at each reidentified line,  between an input
        # spectrum and the shifted and stretched archive spectrum above
        # which a line must be to be considered a good line for
        # reidentification. The local cross-correlation is evaluated at
        # each candidate reidentified line (using a window of
        # nlocal_cc), and is then used to score the the reidentified
        # lines to arrive at the final set of good reidentifications.
        cc_local_thresh = 0.7
        # Size of pixel window used for local cross-correlation
        # computation for each arc line. If not an odd number one will
        # be added to it to make it odd.
        nlocal_cc = 11
        # Minimum RMS for keeping a slit/order solution. This can be a
        # single number or a list/array providing the value for each
        # slit. Only used if ``method`` is either 'holy-grail' or
        # 'reidentify'
        rms_threshold = 0.2
        # Matching tolerance in pixels when searching for new lines.
        # This is the difference in pixels between the wavlength
        # assigned to an arc line by an iteration of the wavelength
        # solution to the wavelength in the line list.  This parameter
        # is also used as the matching tolerance in pixels for a line
        # reidentification.  A good line match must match within this
        # tolerance to the shifted and stretched archive spectrum, and
        # the archive wavelength solution at this match must be within
        # match_toler dispersion elements from the line in line list.
        match_toler = 2.0
        # Function used for wavelength solution fits
        func = legendre
        # Order of first guess fit to the wavelength solution.
        n_first = 2
        # Order of final fit to the wavelength solution (there are
        # n_final+1 parameters in the fit). This can be a single number
        # or a list/array providing the value for each slit
        n_final = 4
        # Number of sigma for rejection for the first guess to the
        # wavelength solution.
        sigrej_first = 2.0
        # Number of sigma for rejection for the final guess to the
        # wavelength solution.
        sigrej_final = 3.0
        # Number of brightest arc lines to search for in preliminary
        # identification
        numsearch = 20
        # Number of pixels to fit when deriving the centroid of the arc
        # lines (an odd number is best)
        nfitpix = 5
        # One or more pixels at which to manually identify a line
        IDpixels = None
        # Wavelengths of the manually identified lines
        IDwaves = None
        # Frame of reference for the wavelength calibration.  Options
        # are: observed, heliocentric, barycentric
        refframe = heliocentric
        # Number of spectra to chop the arc spectrum into when
        # ``method`` is 'full_template'
        nsnippet = 2
        # If True, restrict to lines matching the instrument.  WARNING:
        # This is only implemented for shane_kast_red + HolyGrail.  Do
        # not use it unless you really know what you are doing.
        use_instr_flag = False
        # Cut the arxiv template down to this specified wavelength range
        # [min,max]
        wvrng_arxiv = None
    # Slit-edge tracing parameters
    [[slitedges]]
        # Number of median-filtering iterations to perform on
        # sqrt(trace) image before applying to Sobel filter to detect
        # slit/order edges.
        filt_iter = 0
        # Mode for Sobel filtering.  Default is 'nearest'; note we
        # find'constant' works best for DEIMOS.
        sobel_mode = nearest
        # Threshold for finding edges in the Sobel-filtered significance
        # image.
        edge_thresh = 20.0
        # Enhance the sobel filtering? A value of 0 will not enhance the
        # sobel filtering.Any other value > 0 will sum the sobel values.
        # For example, a value of 3 willcombine the sobel values for the
        # 3 nearest pixels. This is useful when a slitedge is poorly
        # defined (e.g. vignetted).
        sobel_enhance = 0
        # User-defined regions to exclude from the slit tracing. To set
        # this parameter, the text should be a comma separated list of
        # pixel ranges (in the x direction) to be excluded and the
        # detector number. For example, the following string
        # 1:0:20,1:300:400  would select two regions in det=1 between
        # pixels 0 and 20 and between 300 and 400.
        exclude_regions = None
        # In the initial connection of spectrally adjacent edge
        # detections, this sets the number of previous spectral rows to
        # consider when following slits forward.
        follow_span = 20
        # The minimum spectral length (as a fraction of the detector
        # size) of a trace determined by direct measurements of the
        # detector data (as opposed to what should be included in any
        # modeling approach; see fit_min_spec_length).
        det_min_spec_length = 0.33
        # Maximum spatial shift in pixels between an input edge location
        # and the recentroided value.
        max_shift_abs = 0.5
        # Maximum spatial shift in pixels between the edges in adjacent
        # spectral positions.
        max_shift_adj = 0.15
        # Maximum error in the spatial position of edges in pixels.
        max_spat_error = None
        # Same-side slit edges below this separation in pixels are
        # considered part of the same edge.
        match_tol = 3.0
        # Function fit to edge measurements.  Options are: polynomial,
        # legendre, chebyshev
        fit_function = legendre
        # Order of the function fit to edge measurements.
        fit_order = 3
        # Maximum deviation between the fitted and measured edge
        # position for rejection in spatial pixels.
        fit_maxdev = 5.0
        # Maximum number of rejection iterations during edge fitting.
        fit_maxiter = 25
        # Number of iterations of re-measuring and re-fitting the edge
        # data; see :func:`pypeit.core.trace.fit_trace`.
        fit_niter = 1
        # Minimum unmasked spectral length of a traced slit edge to use
        # in any modeling procedure (polynomial fitting or PCA
        # decomposition).
        fit_min_spec_length = 0.6
        # During automated tracing, attempt to construct a PCA
        # decomposition of the traces. When True, the edge traces
        # resulting from the initial detection, centroid refinement, and
        # polynomial fitting must meet a set of criteria for performing
        # the pca; see :func:`pypeit.edgetrace.EdgeTraceSet.can_pca`.
        # If False, the ``sync_predict`` parameter *cannot* be set to
        # ``pca``; if it is not, the value is set to ``nearest`` and a
        # warning is issued when validating the parameter set.
        auto_pca = True
        # Construct a PCA decomposition for the left and right traces
        # separately.  This can be important for cross-dispersed echelle
        # spectrographs (e.g., Keck-NIRES)
        left_right_pca = False
        # Minimum number of edge traces required to perform a PCA
        # decomposition of the trace form.  If left_right_pca is True,
        # this minimum applies to the number of left and right traces
        # separately.
        pca_min_edges = 4
        # The number of PCA components to keep, which must be less than
        # the number of detected traces.  If not provided, determined by
        # calculating the minimum number of components required to
        # explain a given percentage of variance in the edge data; see
        # `pca_var_percent`.
        pca_n = None
        # The percentage (i.e., not the fraction) of the variance in the
        # edge data accounted for by the PCA used to truncate the number
        # of PCA coefficients to keep (see `pca_n`).  Ignored if `pca_n`
        # is provided directly.
        pca_var_percent = 99.8
        # Type of function fit to the PCA coefficients for each
        # component.  Options are: polynomial, legendre, chebyshev
        pca_function = polynomial
        # Order of the function fit to the PCA coefficients.
        pca_order = 2
        # Sigma rejection threshold for fitting PCA components.
        # Individual numbers are used for both lower and upper
        # rejection. A list of two numbers sets these explicitly (e.g.,
        # [2., 3.]).
        pca_sigrej = 2.0, 2.0
        # Maximum number of PCA coefficients rejected during a given fit
        # iteration.
        pca_maxrej = 1
        # Maximum number of rejection iterations when fitting the PCA
        # coefficients.
        pca_maxiter = 25
        # Range of the slit in the spectral direction (in fractional
        # units) to smash when searching for slit edges.  If the
        # spectrum covers only a portion of the image, use that range.
        smash_range = 0.0, 1.0
        # Sigma clipping level for peaks detected in the collapsed,
        # Sobel-filtered significance image.
        edge_detect_clip = None
        # After detection of peaks in the rectified Sobel-filtered image
        # and before refitting the edge traces, the rectified image is
        # median filtered with a kernel width of
        # `trace_median_frac*nspec` along the spectral dimension.
        trace_median_frac = None
        # After rectification and median filtering of the Sobel-filtered
        # image (see `trace_median_frac`), values in the median-filtered
        # image *below* this threshold are masked in the refitting of
        # the edge trace data.  If None, no masking applied.
        trace_thresh = None
        # The `fwhm` parameter to use when using uniform weighting in
        # :func:`pypeit.core.trace.fit_trace` when refining the PCA
        # predictions of edges.  See description of
        # :func:`pypeit.core.trace.peak_trace`.
        fwhm_uniform = 3.0
        # The number of iterations of
        # :func:`pypeit.core.trace.fit_trace` to use when using uniform
        # weighting.
        niter_uniform = 9
        # The `fwhm` parameter to use when using Gaussian weighting in
        # :func:`pypeit.core.trace.fit_trace` when refining the PCA
        # predictions of edges.  See description
        # :func:`pypeit.core.trace.peak_trace`.
        fwhm_gaussian = 3.0
        # The number of iterations of
        # :func:`pypeit.core.trace.fit_trace` to use when using Gaussian
        # weighting.
        niter_gaussian = 6
        # The minimum separation between the detector edges and a slit
        # edge for any added edge traces.  Must be positive.
        det_buffer = 5
        # If parts of any (predicted) trace fall off the detector edge,
        # allow them to be nudged away from the detector edge up to and
        # including this maximum number of pixels.  If None, no limit is
        # set; otherwise should be 0 or larger.
        max_nudge = None
        # Mode to use when predicting the form of the trace to insert.
        # Use `pca` to use the PCA decomposition or `nearest` to
        # reproduce the shape of the nearest trace.
        sync_predict = pca
        # Mode to use for determining the location of traces to insert.
        # Use `median` to use the median of the matched left and right
        # edge pairs, `nearest` to use the length of the nearest slit,
        # or `gap` to offset by a fixed gap width from the next slit
        # edge.
        sync_center = gap
        # Offset (pixels) used for the slit edge gap width when
        # inserting slit edges (see `sync_center`) or when nudging
        # predicted slit edges to avoid slit overlaps.  This should be
        # larger than `minimum_slit_gap` when converted to arcseconds.
        gap_offset = 5.0
        # If adding a first left edge or a last right edge, ignore
        # `center_mode` for these edges and place them at the edge of
        # the detector (with the relevant shape).
        sync_to_edge = True
        # When the code is ready to synchronize the left/right trace
        # edges, the traces should have been constructed, vetted, and
        # cleaned. This can sometimes lead to *no* valid traces. This
        # parameter dictates what to do next. If ``bound_detector`` is
        # True, the code will artificially add left and right edges that
        # bound the detector; if False, the code identifies the slit-
        # edge tracing as being unsuccessful, warns the user, and ends
        # gracefully. Note that setting ``bound_detector`` to True is
        # needed for some long-slit data where the slit edges are, in
        # fact, beyond the edges of the detector.
        bound_detector = False
        # Minimum slit length in arcsec.  Slit lengths are determined by
        # the median difference between the left and right edge
        # locations for the unmasked trace locations.  This is used to
        # identify traces that are *erroneously* matched together to
        # form slits.  Short slits are expected to be ignored or removed
        # (see  ``clip``).  If None, no minimum slit length applied.
        minimum_slit_length = 4.0
        # Minimum slit length in arcsec for a science slit.  Slit
        # lengths are determined by the median difference between the
        # left and right edge locations for the unmasked trace
        # locations.  Used in combination with ``minimum_slit_length``,
        # this parameter is used to identify box or alignment slits;
        # i.e., those slits that are shorter than
        # ``minimum_slit_length_sci`` but larger than
        # ``minimum_slit_length`` are box/alignment slits.  Box slits
        # are *never* removed (see ``clip``), but no spectra are
        # extracted from them.  If None, no minimum science slit length
        # is applied.
        minimum_slit_length_sci = 6
        # Allowed range in slit length compared to the median slit
        # length.  For example, a value of 0.3 means that slit lengths
        # should not vary more than 30%.  Relatively shorter or longer
        # slits are masked or clipped.  Most useful for echelle or
        # multi-slit data where the slits should have similar or
        # identical lengths.
        length_range = None
        # Minimum slit gap in arcsec.  Gaps between slits are determined
        # by the median difference between the right and left edge
        # locations of adjacent slits.  Slits with small gaps are merged
        # by removing the intervening traces.If None, no minimum slit
        # gap is applied.  This should be smaller than `gap_offset` when
        # converted to pixels.
        minimum_slit_gap = None
        # Remove traces flagged as bad, instead of only masking them.
        # This is currently only used by
        # :func:`~pypeit.edgetrace.EdgeTraceSet.centroid_refine`.
        clip = True
        # For echelle spectrographs, this is the tolerance allowed for
        # matching identified "slits" to echelle orders. Must be in the
        # fraction of the detector spatial scale (i.e., a value of 0.05
        # means that the order locations must be within 5% of the
        # expected value).  If None, no limit is used.
        order_match = None
        # Offset to introduce to the expected order positions to improve
        # the match for this specific data. This is an additive offset
        # to the measured slit positions; i.e., this should minimize the
        # difference between the expected order positions and
        # ``self.slit_spatial_center() + offset``. Must be in the
        # fraction of the detector spatial scale. If None, no offset is
        # applied.
        order_offset = None
        # Use slit-mask designs to identify slits.
        use_maskdesign = False
        # Maximum allowed offset in pixels between the slit edges
        # defined by the slit-mask design and the traced edges.
        maskdesign_maxsep = 50
        # Step in pixels used to generate a list of possible offsets
        # (within +/- `maskdesign_maxsep`) between the slit edges
        # defined by the mask design and the traced edges.
        maskdesign_step = 1
        # Number of sigma for sigma-clipping rejection during slit-mask
        # design matching.
        maskdesign_sigrej = 3
        # Integer number of pixels to consider beyond the slit edges
        # when selecting pixels that are 'on' the slit.
        pad = 0
        # Add one or more user-defined slits.  The syntax to define a
        # slit to add is: 'det:spec:spat_left:spat_right' where
        # det=detector, spec=spectral pixel, spat_left=spatial pixel of
        # left slit boundary, and spat_righ=spatial pixel of right slit
        # boundary.  For example, '2:2000:2121:2322,3:2000:1201:1500'
        # will add a slit to detector 2 passing through spec=2000
        # extending spatially from 2121 to 2322 and another on detector
        # 3 at spec=2000 extending from 1201 to 1500.
        add_slits = None
        # Sets the method used to predict the shape of the left and
        # right traces for a user-defined slit inserted.  Options are
        # (1) ``straight`` inserts traces with a constant spatial pixels
        # position, (2) ``nearest`` inserts traces with a form identical
        # to the automatically identified trace at the nearest spatial
        # position to the inserted slit, or (3) ``pca`` uses the PCA
        # decomposition to predict the shape of the traces.
        add_predict = nearest
        # Remove one or more user-specified slits.  The syntax used to
        # define a slit to remove is: 'det:spec:spat' where
        # det=detector, spec=spectral pixel, spat=spatial pixel.  For
        # example, '2:2000:2121,3:2000:1500' will remove the slit on
        # detector 2 that contains pixel (spat,spec)=(2000,2121) and on
        # detector 3 that contains pixel (2000,2121).
        rm_slits = None
    # Define how to trace the slit tilts using the trace frames
    [[tilts]]
        # Only use the arc lines that have an identified wavelength to
        # trace tilts (CURRENTLY NOT USED!)
        idsonly = False
        # Significance threshold for arcs to be used in tracing
        # wavelength tilts. This can be a single number or a list/array
        # providing the value for each slit/order.
        tracethresh = 25
        # Significance threshold for arcs to be used in line
        # identification for the purpose of identifying neighboring
        # lines.The tracethresh parameter above determines the
        # significance threshold of lines that will be traced, but these
        # lines must be at least nfwhm_neigh fwhm away from neighboring
        # lines. This parameter determines the significance above which
        # a line must be to be considered a possible colliding neighbor.
        # A low value of sig_neigh will result in an overall larger
        # number of lines, which will result in more lines above
        # tracethresh getting rejected
        sig_neigh = 10.0
        # Required separation between neighboring arc lines for them to
        # be considered for tilt tracing in units of the the spectral
        # fwhm (see wavelength parset where fwhm is defined)
        nfwhm_neigh = 3.0
        # Maximum absolute deviation (in units of fwhm) for the legendre
        # polynomial fits to individual arc line tilt fits during
        # iterative trace fitting (flux weighted, then gaussian
        # weighted)
        maxdev_tracefit = 1.0
        # Outlier rejection significance to determine which traced arc
        # lines should be included in the global fit
        sigrej_trace = 3.0
        # Order of the legendre polynomial to be fit to the the tilt of
        # an arc line. This parameter determinesboth the orer of the
        # *individual* arc line tilts, as well as the order of the
        # spatial direction of the2d legendre polynomial (spatial,
        # spectral) that is fit to obtain a global solution for the
        # tilts across theslit/order. This can be a single number or a
        # list/array providing the value for each slit
        spat_order = 4
        # Order of the spectral direction of the 2d legendre polynomial
        # (spatial, spectral) that is fit to obtain a global solution
        # for the tilts across the slit/order. This can be a single
        # number or a list/array providing the value for each slit
        spec_order = 7
        # Type of function for 2D fit
        func2d = legendre2d
        # Maximum absolute deviation (in units of fwhm) rejection
        # threshold used to determines which pixels in global 2d fits to
        # arc line tilts are rejected because they deviate from the
        # model by more than this value
        maxdev2d = 1.0
        # Outlier rejection significance determining which pixels on a
        # fit to an arc line tilt are rejected by the global 2D fit
        sigrej2d = 5.0
        # Before tracing the line center at each spatial position,
        # remove any low-order continuum in the 2D spectra.
        rm_continuum = False
        # The sigma threshold for rejection.  Can be a single number or
        # two numbers that give the low and high sigma rejection,
        # respectively.
        cont_rej = 3, 1.5
        # Sets how far below the last measured tilt line is extrapolated
        # in tracewave.fit_tilts()
        minmax_extrap = 150.0, 1000.0
# The frames and combination rules for the science observations
[scienceframe]
    # Frame type.  Options are: align, arc, bias, dark, pinhole,
    # pixelflat, illumflat, science, standard, trace, tilt, sky
    frametype = science
    # A master calibrations file to use if it exists.
    useframe = None
    # Used in identifying frames of this type.  This sets the minimum
    # and maximum allowed exposure times.  There must be two items in
    # the list.  Use None to indicate no limit; i.e., to select
    # exposures with any time greater than 30 sec, use exprng = [30,
    # None].
    exprng = 60, None
    # Low level parameters used for basic image processing
    [[process]]
        # Trim the image to the detector supplied region
        trim = True
        # Convert the ADUs to electrons using the detector gain
        apply_gain = True
        # Orient the raw image into the PypeIt frame
        orient = True
        # Method used to fit the overscan. Options are: polynomial,
        # savgol, median
        overscan_method = savgol
        # Parameters for the overscan subtraction.  For 'polynomial',
        # set overcan_par = order, number of pixels, number of repeats ;
        # for 'savgol', set overscan_par = order, window size ; for
        # 'median', set overscan_par = None or omit the keyword.
        overscan_par = 5, 65
        # Method used to combine multiple frames.  Options are: median,
        # mean
        combine = mean
        # Handling of saturated pixels.  Options are: reject, force,
        # nothing
        satpix = reject
        # Identify CRs and mask them
        mask_cr = True
        # Perform sigma clipping when combining.  Only used with
        # combine=mean
        clip = True
        # Number of pixels to reject at the lowest and highest ends of
        # the distribution; i.e., n_lohi = low, high.  Use None for no
        # limit.
        n_lohi = 0, 0
        # Maximum number of iterations for LA cosmics routine.
        lamaxiter = 1
        # Factor by which to expand regions with cosmic rays detected by
        # the LA cosmics routine.
        grow = 1.5
        # Sigma-clipping level for when clip=True; Use None for
        # automatic limit (recommended).
        comb_sigrej = None
        # Remove compact detections in LA cosmics routine
        rmcompact = True
        # Sigma level for rejection in LA cosmics routine
        sigclip = 5.0
        # Fraction for the lower clipping threshold in LA cosmics
        # routine.
        sigfrac = 0.3
        # Object detection limit in LA cosmics routine
        objlim = 5.0
        # Use a bias image.  If True, one or more must be supplied in
        # the PypeIt file.
        use_biasimage = True
        # Subtract off the overscan.  Detector *must* have one or code
        # will crash.
        use_overscan = True
        # Subtract off a dark image.  If True, one or more darks must be
        # provided.
        use_darkimage = False
        # If designated dark frames are used and have a different
        # exposure time than the science frames, scale the counts by the
        # by the ratio in the exposure times to adjust the dark counts
        # for the difference in exposure time.  WARNING: You should
        # always take dark frames that have the same exposure time as
        # your science frames, so use this option with care!
        dark_expscale = False
        # If True, use the standard deviation in the overscan region to
        # measure an empirical readnoise to use in the noise model.
        empirical_rn = False
        # Use the bias- and dark-subtracted image to calculate and
        # include electron count shot noise in the image processing
        # error budget
        shot_noise = True
        # Impose a noise floor by adding the provided fraction of the
        # bias- and dark-subtracted electron counts to the error budget.
        # E.g., a value of 0.01 means that the S/N of the counts in the
        # image will never be greater than 100.
        noise_floor = 0.01
        # Use the pixel flat to make pixel-level corrections.  A
        # pixelflat image must be provied.
        use_pixelflat = True
        # Use the illumination flat to correct for the illumination
        # profile of each slit.
        use_illumflat = True
        # Use the relative spectral illumination profiles to correct the
        # spectral illumination profile of each slit. This is primarily
        # used for IFUs.  To use this, you must set
        # ``slit_illum_relative=True`` in the ``flatfield`` parameter
        # set!
        use_specillum = False
        # Subtract off a detector pattern. This pattern is assumed to be
        # sinusoidal along one direction, with a frequency that is
        # constant across the detector.
        use_pattern = False
        # Subtract off the continuum level from an image. This parameter
        # should only be set to True to combine arcs with multiple
        # different lamps.For all other cases, this parameter should
        # probably be False.
        use_continuum = False
        # Correct slits, illumination flat, etc. for flexure
        spat_flexure_correct = True
# Parameters determining sky-subtraction, object finding, and extraction
[reduce]
    # Trim the slit by this number of pixels left/right when performing
    # sky subtraction
    trim_edge = 3, 3
    # Parameters for the find object and tracing algorithms
    [[findobj]]
        # Order of legendre polynomial fits to object traces.
        trace_npoly = 5
        # S/N threshold for object finding in wavelength direction
        # smashed image.
        snr_thresh = 10.0
        # Trim the slit by this number of pixels left/right before
        # finding objects
        find_trim_edge = 5, 5
        # Maximum deviation of pixels from polynomial fit to trace used
        # to reject bad pixels in trace fitting.
        find_maxdev = 2.0
        # Polynomial order used for trace extrapolation
        find_extrap_npoly = 3
        # Maximum number of objects to extract in a science frame.  Use
        # None for no limit. This parameter can be useful in situations
        # where systematics lead to spurious extra objects. Setting this
        # parameter means they will be trimmed. For mulitslit maxnumber
        # applies per slit, for echelle observations this applies per
        # order. Note that objects on a slit/order impact the sky-
        # modeling and so maxnumber should never be lower than the true
        # number of detectable objects on your slit. For image
        # differenced observations with positive and negative object
        # traces, maxnumber appliesto the number of positive (or
        # negative) traces individually. In other words, if you had two
        # positive objects andone negative object, then you would set
        # maxnumber to be equal to two (not three). Note that if
        # manuallyextracted apertures are explicitly requested, they do
        # not count against this maxnumber. If more than maxnumber
        # objects are detected, then highest S/N ratio objects will be
        # the ones that are kept. For multislit observations the choice
        # here depends on the slit length. For echelle observations with
        # short slits we set the default to be 1
        maxnumber_sci = 10
        # Maximum number of objects to extract in a standard star frame.
        # Same functionality as maxnumber_sci documented above. For
        # multislit observations the default here is 5, for
        # echelleobservations the default is 1
        maxnumber_std = 5
        # Indicates roughly the fwhm of objects in pixels for object
        # finding
        find_fwhm = 5.0
        # Criteria for keeping echelle objects. They must either have a
        # maximum S/N across all the orders greater than this value or
        # satisfy the min_snr criteria described by the min_snr
        # parameters. If maxnumber is set (see above) then these
        # criteriawill be applied but only the maxnumber highest
        # (median) S/N ratio objects will be kept.
        ech_find_max_snr = 1.0
        # Criteria for keeping echelle objects. They must either have a
        # maximum S/N across all the orders greater than
        # ech_find_max_snr,  value or they must have S/N >
        # ech_find_min_snr on >= ech_find_nabove_min_snr orders. If
        # maxnumber is set (see above) then these criteriawill be
        # applied but only the maxnumber highest (median) S/N ratio
        # objects will be kept.
        ech_find_min_snr = 0.3
        # Criteria for keeping echelle objects. They must either have a
        # maximum S/N across all the orders greater than
        # ech_find_max_snr,  value or they must have S/N >
        # ech_find_min_snr on >= ech_find_nabove_min_snr orders. If
        # maxnumber is set (see above) then these criteriawill be
        # applied but only the maxnumber highest (median) S/N ratio
        # objects will be kept.
        ech_find_nabove_min_snr = 2
        # Only perform one round of object finding (mainly for
        # quick_look)
        skip_second_find = False
        # If True, do not update initial sky to get global sky using
        # updated noise model. This should be True for quicklook to save
        # time. This should also be True for near-IR reductions which
        # perform difference imaging, since there we fit sky-residuals
        # rather than the sky itself, so there is no noise model to
        # update.
        skip_final_global = False
        # Identify negative objects in object finding for spectra that
        # are differenced. This is used to manually override the default
        # behavior in PypeIt for object finding by setting this
        # parameter to something other than NoneThe default behavior is
        # that PypeIt will search for negative object traces if
        # background frames are present in the PypeIt file that are
        # classified as "science" (i.e. via pypeit_setup -b, and setting
        # bkg_id in the PypeIt file). If background frames are
        # presentthat are classified as "sky", then PypeIt will NOT
        # search for negative object traces. If one wishesto explicitly
        # override this default behavior, set this parameter to True to
        # find negative objects or False to ignore them.
        find_negative = None
        # It defines the minimum and maximum of your object in the
        # spectral direction on thedetector. It only used for object
        # finding. This parameter is helpful if your object onlyhas
        # emission lines or at high redshift and the trace only shows in
        # part of the detector.
        find_min_max = None
    # Parameters for sky subtraction algorithms
    [[skysub]]
        # Break-point spacing for the bspline sky subtraction fits.
        bspline_spacing = 0.8
        # Rejection parameter for local sky subtraction
        sky_sigrej = 3.0
        # Global sky subtraction will be performed on standard stars.
        # This should be turned off for example for near-IR reductions
        # with narrow slits, since bright standards can fill the slit
        # causing global sky-subtraction to fail. In these situations we
        # go straight to local sky-subtraction since it is designed to
        # deal with such situations
        global_sky_std = True
        # Turn off polynomial basis (Legendre) in global sky subtraction
        no_poly = False
        # A user-defined sky regions mask can be set using this keyword.
        # To allow the code to identify the sky regions automatically,
        # set this variable to an empty string. If you wish to set the
        # sky regions, The text should be a comma separated list of
        # percentages to apply to _all_ slits  For example: The
        # following string   :10,35:65,80:   would select the first 10%,
        # the inner 30%, and the final 20% of _all_ slits.
        user_regions = None
        # Perform a simultaneous joint fit to sky regions using all
        # available slits. Currently, this parameter is only used for
        # IFU data reduction.
        joint_fit = False
        # Load a user-defined sky regions mask to be used for the sky
        # regions. Note, if you set this to True, you must first run the
        # pypeit_skysub_regions GUI to manually select and store the
        # regions to file.
        load_mask = False
        # In global sky evaluation, mask the sky region around the
        # object by the boxcar radius (set in ExtractionPar).
        mask_by_boxcar = False
        # If True, turn off local sky model evaluation, but do fit
        # object profile and perform optimal extraction
        no_local_sky = False
    # Parameters for extraction algorithms
    [[extraction]]
        # Boxcar radius in arcseconds used for boxcar extraction
        boxcar_radius = 1.5
        # prof_nsigma parameter for Standard star extraction.  Prevents
        # undesired rejection.
        std_prof_nsigma = 30.0
        # S/N threshold for performing the more sophisticated optimal
        # extraction which performs a b-spline fit to the object
        # profile. For S/N < sn_gauss the code will simply optimal
        # extractwith a Gaussian with FWHM determined from the object
        # finding.
        sn_gauss = 4.0
        # If True local sky subtraction will be performed on the entire
        # slit. If False, local sky subtraction will be applied to only
        # a restricted region around each object. This should be set to
        # True for either multislit observations using narrow slits or
        # echelle observations with narrow slits
        model_full_slit = False
        # Do not perform an object extraction
        skip_extraction = False
        # Perform boxcar extraction only (i.e. skip Optimal and local
        # skysub)
        skip_optimal = False
        # Mask pixels rejected during profile fitting when
        # extracting.Turning this off may help with bright emission
        # lines.
        use_2dmodel_mask = True
        # Boolean indicating if PypeIt should use the FWHM provided by
        # the user (``find_fwhm`` in `FindObjPar`) for the optimal
        # extraction. If this parameter is ``False`` (default), PypeIt
        # estimates the FWHM for each detected object, and uses
        # ``find_fwhm`` as initial guess.
        use_user_fwhm = False
        # If ``True`` the negative traces will be extracted and saved to
        # disk
        return_negative = False
    # Parameters for cube generation algorithms
    [[cube]]
        # If the data use slits in one spatial direction, set this to
        # True. If the data uses fibres for all spaxels, set this to
        # False.
        slit_spec = True
        # If set to True, the combined frames will use a relative
        # weighting scheme. This only works well if there is a common
        # continuum source in the field of view of all input
        # observations, and is generally only required if high relative
        # precision is desired.
        relative_weights = False
        # If set to True, the input frames will be combined. Otherwise,
        # a separate datacube will be generated for each input spec2d
        # file, and will be saved as a spec3d file.
        combine = False
        # If combining multiple frames, this string sets the output
        # filename of the combined datacube. If combine=False, the
        # output filenames will be prefixed with "spec3d_*"
        output_filename = 
        # Filename of a standard star datacube. This cube will be used
        # to correct the relative scales of the slits, and to flux
        # calibrate the science datacube.
        standard_cube = None
        # White light image of a previously combined datacube. The white
        # light image will be used as a reference when calculating the
        # offsets of the input spec2d files.
        reference_image = None
        # Save a white light image of the combined datacube. The output
        # filename will be given by the "output_filename" variable with
        # a suffix "_whitelight". Note that the white light image
        # collapses the flux along the wavelength axis, so some spaxels
        # in the 2D white light image may have different wavelength
        # ranges. If combine=False, the individual spec3d files will
        # have a suffix "_whitelight".
        save_whitelight = False
        # Minimum RA to use when generating the WCS. If None, the
        # default is minimum RA based on the WCS of all spaxels. Units
        # should be degrees.
        ra_min = None
        # Maximum RA to use when generating the WCS. If None, the
        # default is maximum RA based on the WCS of all spaxels. Units
        # should be degrees.
        ra_max = None
        # Minimum DEC to use when generating the WCS. If None, the
        # default is minimum DEC based on the WCS of all spaxels. Units
        # should be degrees.
        dec_min = None
        # Maximum DEC to use when generating the WCS. If None, the
        # default is maximum DEC based on the WCS of all spaxels. Units
        # should be degrees.
        dec_max = None
        # Minimum wavelength to use when generating the WCS. If None,
        # the default is minimum wavelength based on the WCS of all
        # spaxels. Units should be Angstroms.
        wave_min = None
        # Maximum wavelength to use when generating the WCS. If None,
        # the default is maximum wavelength based on the WCS of all
        # spaxels. Units should be Angstroms.
        wave_max = None
        # The spatial size of each spaxel to use when generating the WCS
        # (in arcsec). If None, the default is set by the spectrograph
        # file.
        spatial_delta = None
        # The wavelength step to use when generating the WCS (in
        # Angstroms). If None, the default is set by the wavelength
        # solution.
        wave_delta = None
        # If true, an astrometric correction will be applied using the
        # alignment frames.
        astrometric = True
        # This option performs a small correction for the relative blaze
        # function of all input frames that have (even slightly)
        # different grating angles, or if you are flux calibrating your
        # science data with a standard star that was observed with a
        # slightly different setup.
        grating_corr = True
        # This option performs a small correction for the relative
        # spectral illumination scale of different spec2D files. specify
        # the relative path+file to the spec2D file that you would like
        # to use for the relative scaling. If you want to perform this
        # correction, it is best to use the spec2d file with the highest
        # S/N sky spectrum. You should choose the same frame for both
        # the standards and science frames.
        scale_corr = None
    # Parameters for slitmask
    [[slitmask]]
        # If slitmask design information is provided, and slit matching
        # is performed (``use_maskdesign = True`` in ``EdgeTracePar``),
        # this parameter provides the desired tolerance (arcsec) to
        # match sources to targeted objects
        obj_toler = 1.0
        # If SlitMask object was generated, assign RA,DEC,name to
        # detected objects
        assign_obj = False
        # Objects detected above this significance threshold will be
        # used to compute the slitmask offset. This is the default
        # behaviour for DEIMOS  unless ``slitmask_offset``,
        # ``bright_maskdef_id`` or ``use_alignbox`` is set.
        nsig_thrshd = 50.0
        # User-provided slitmask offset (pixels) from the position
        # expected by the slitmask design. This is optional, and if set
        # PypeIt will NOT compute the offset using `nsig_thrshd` or
        # `bright_maskdef_id`.
        slitmask_offset = None
        # Use the dither offset recorded in the header of science frames
        # as the value of the slitmask offset. This is currently only
        # available for Keck MOSFIRE reduction and it is set as the
        # default for this instrument. If set PypeIt will NOT compute
        # the offset using `nsig_thrshd` or `bright_maskdef_id`.
        # However, it is ignored if ``slitmask_offset`` is provided.
        use_dither_offset = False
        # `maskdef_id` (corresponding to `dSlitId` and `Slit_Number` in
        # the DEIMOS and MOSFIRE slitmask design, respectively) of a
        # slit containing a bright object that will be used to compute
        # the slitmask offset. This parameter is optional and is ignored
        # if ``slitmask_offset`` is provided.
        bright_maskdef_id = None
        # Force extraction of undetected objects at the location
        # expected from the slitmask design.
        extract_missing_objs = False
        # Indicates the FWHM in arcsec for the force extraction of
        # undetected objects. PypeIt will try to determine the FWHM from
        # the flux profile (by using ``missing_objs_fwhm`` as initial
        # guess). If the FWHM cannot be determined,
        # ``missing_objs_fwhm`` will be assumed. If you do not want
        # PypeIt to try to determine the FWHM set the parameter
        # ``use_user_fwhm`` in ``ExtractionPar`` to True. If
        # ``missing_objs_fwhm`` is ``None`` (which is the default)
        # PypeIt will use the median FWHM of all the detected objects.
        missing_objs_fwhm = None
        # Indicates the boxcar radius in arcsec for the force extraction
        # of undetected objects.
        missing_objs_boxcar_rad = 1.0
        # Use stars in alignment boxes to compute the slitmask offset.
        # If this is set to ``True`` PypeIt will NOT compute the offset
        # using `nsig_thrshd` or `bright_maskdef_id`
        use_alignbox = False
# Parameters used by the flexure-correction procedure.  Flexure
# corrections are not performed by default.  To turn on, either set the
# parameters in the 'flexure' parameter group or set 'flexure = True' in
# the 'rdx' parameter group to use the default flexure-correction
# parameters.
[flexure]
    # Method used to correct for flexure. Use skip for no correction.
    # If slitcen is used, the flexure correction is performed before the
    # extraction of objects (not recommended).  Options are: None,
    # boxcar, slitcen, skip
    spec_method = boxcar
    # Maximum allowed spectral flexure shift in pixels.
    spec_maxshift = 20
    # Archive sky spectrum to be used for the flexure correction.
    spectrum = paranal_sky.fits
    # Minimum S/N for analyzing sky spectrum for flexure
    multi_min_SN = 1
# Parameters used by the flux-calibration procedure.  Flux calibration
# is not performed by default.  To turn on, either set the parameters in
# the 'fluxcalib' parameter group or set 'fluxcalib = True' in the 'rdx'
# parameter group to use the default flux-calibration parameters.
[fluxcalib]
    # The default behavior for atmospheric extinction corrections is
    # that if UVIS algorithm is used (which does not correct for
    # telluric absorption) than an atmospheric extinction model is used
    # to correct for extinction below 10000A, whereas if the IR
    # algorithm is used, then no extinction correction is applied since
    # the atmosphere is modeled directly. To follow thesedefaults based
    # on the algorithm this parameter should be set to
    # extinct_correct=None. If instead this parameter is set, this
    # overide this default behavior. In other words, it will force an
    # extinction correctionif extinct_correct=True, and will not perform
    # an extinction correction if extinct_correct=False.
    extinct_correct = None
    # If False (default), the code will barf if one tries to use
    # sensfunc at wavelengths outside its defined domain. By changing
    # the par['sensfunc']['extrap_blu'] and
    # par['sensfunc']['extrap_red'] this domain can be extended. If True
    # the code will blindly extrapolate.
    extrap_sens = False
    # Use an archived sensfunc to flux calibration
    use_archived_sens = False
# Par set to control 1D coadds.  Only used in the after-burner script.
[coadd1d]
    # The extraction to coadd, i.e. optimal or boxcar. Must be either
    # 'OPT' or 'BOX'
    ex_value = OPT
    # If True (default), the code will coadd the fluxed spectra (i.e.
    # the FLAM) in the spec1d files. If False, it will coadd the counts.
    flux_value = True
    # Number of edge pixels to mask. This should be removed/fixed.
    nmaskedge = 2
    # Number of pixels to median filter by when computing S/N used to
    # decide how to scale and weight spectra. If set to None (default),
    # the code will determine the effective number of good pixels per
    # spectrum in the stack that is being co-added and use 10% of this
    # neff.
    sn_smooth_npix = None
    # Method used to construct wavelength grid for coadding spectra. The
    # routine that creates the wavelength is
    # :func:`~pypeit.core.wavecal.wvutils.get_wave_grid`. The options
    # are: 'iref' -- Use the first wavelength array'velocity' -- Grid is
    # uniform in velocity'log10' -- Grid is uniform in log10(wave).This
    # is the same as velocity.'linear' -- Grid is uniform in
    # lamba.'concatenate' -- Meld the input wavelength arrays
    wave_method = linear
    # Dispersion in units of km/s in case you want to specify it in the
    # get_wave_grid  (for the 'velocity' option),otherwise a median
    # value is computed from the data.
    dv = None
    # Used in case you want to specify the minimum wavelength in your
    # wavelength grid, default=None computes from data
    wave_grid_min = None
    # Used in case you want to specify the maximum wavelength in your
    # wavelength grid, default=None computes from data
    wave_grid_max = None
    # Make the wavelength grid  sampling finer (spec_samp_fact < 1.0) or
    # coarser (spec_samp_fact > 1.0) by this sampling factor. This
    # basically multiples the 'native' spectral pixels by
    # spec_samp_fact, i.e. units spec_samp_fact are pixels.
    spec_samp_fact = 1.0
    # Percentile used for selecting the minimum SNR cut from a reference
    # spectrum used to robustly determine the median ratio between
    # spectra. This parameter is used by coadd1d.robust_median_ratio as
    # part of the automatic rescaling procedure. Pixels above this
    # percentile cut are deemed the "good" pixels and are used to
    # compute the ratio of two spectra.  This must be a number between 0
    # and 100.
    ref_percentile = 70.0
    # Maximum number of iterations performed for rescaling spectra.
    maxiter_scale = 5
    # Rejection threshold used for rejecting pixels when rescaling
    # spectra with scale_spec.
    sigrej_scale = 3.0
    # Method used to rescale the spectra prior to coadding. The options
    # are: 'auto' -- Determine the scaling method automatically based on
    # the S/N ratio which works well'poly' -- Polynomial
    # rescaling.'median' -- Median rescaling'none' -- Do not
    # rescale.'hand' -- Pass in hand scaling factors. This option is not
    # well tested.
    scale_method = auto
    # For scale method set to 'auto', this sets the minimum SNR for
    # which median scaling is attempted
    sn_min_medscale = 0.5
    # For scale method set to 'auto', this sets the minimum SNR for
    # which polynomial scaling is attempted.
    sn_min_polyscale = 2.0
    # maximum number of iterations for stacking and rejection. The code
    # stops iterating either when the output mask does not change
    # betweeen successive iterations or when maxiter_reject is reached.
    maxiter_reject = 5
    # Lower rejection threshold used for rejecting pixels when combining
    # spectra in units of sigma.
    lower = 3.0
    # Upper rejection threshold used for rejecting pixels when combining
    # spectra in units of sigma.
    upper = 3.0
    # Coadding performs iterative rejection by comparing each exposure
    # to a preliminary stack of all the exposures. If this parameter is
    # set then it will not reject more than maxrej pixels per iteration
    # of this rejection. The default is None, which means no maximum on
    # rejected pixels.
    maxrej = None
    # Errors are capped during rejection so that the S/N is never
    # greater than sn_clip. This prevents overly aggressive rejection in
    # high S/N ratio spectrum which neverthless differ at a level
    # greater than the formal S/N due to systematics.
    sn_clip = 30.0
    # Number of orders to use for estimating the per exposure weights.
    # Default is None, which will just use one fourth of the total
    # number of orders. This is only used for Echelle
    nbest = None
    # File containing sensitivity function which is a requirement for
    # echelle coadds. This is only used for Echelle
    sensfuncfile = ../GD153_lris_sens.fits
    # Output filename
    coaddfile = J1355-0044_coadd.fits
    # Magnitude type.  AB is the only option currently allowed
    mag_type = AB
    # Filter for scaling.  See flux_calib.load_fitler_file() for naming.
    # Ignore if none
    filter = none
    # Magnitude of the source in the given filter
    filter_mag = None
    # List of wavelength regions to mask when doing the scaling (ie.
    # occasional junk pixels).Colon and comma separateed, e.g.
    # 5552:5559,6010:6030
    filter_mask = None
# Par set to control 2D coadds.  Only used in the after-burner script.
[coadd2d]
    # Slit ID, or list of slit IDs that the user want to restrict the
    # coadd to.I.e., only this/these slit/s will be coadded.
    only_slits = None
    # Offsets for the images being combined (spat pixels). Options are:
    # ``maskdef_offsets``, ``auto``, and a list of offsets.Use
    # ``maskdef_offsets`` to use the offsets computed during the
    # slitmask design matching (currently available for DEIMOS and
    # MOSFIRE only). If ``auto`` is chosen, PypeIt will try to compute
    # the offsets using a reference object with the highest S/N, or an
    # object selected by the user (see ``user_obj``). If a list of
    # offsets is provided, PypeIt will use it.
    offsets = auto
    # This parameter provides the desired tolerance in spatial pixel
    # used to identify slits in different exposures
    spat_toler = 5
    # Mode for the weights used to coadd images. Options are: ``auto``,
    # ``uniform``, or a list of weights. If ``auto`` is used, PypeIt
    # will try to compute the weights using a reference object with the
    # highest S/N, or an object selected by the user (see ``user_obj``),
    # if ``uniform`` is used, uniform weights will be applied. If a list
    # of weights is provided, PypeIt will use it.
    weights = auto
    # Object that the user wants to use to compute the weights and/or
    # the offsets for coadding images. For slit spectroscopy, provide
    # the ``SLITID`` and the ``OBJID``, separated by comma, of the
    # selected object. For echelle spectroscopy, provide the
    # ``ECH_OBJID`` of the selected object. See :doc:`out_spec1D` for
    # more info about ``SLITID``, ``OBJID`` and ``ECH_OBJID``. If this
    # parameter is not ``None``, it will be used to compute the offsets
    # only if ``offsets = auto``, and it will used to compute the
    # weights only if ``weights = auto``.
    user_obj = None
    # If True, use the slits to set the trace down the center
    use_slits4wvgrid = False
    # Manual extraction parameters. det:spat:spec:fwhm. Multiple manual
    # extractions are semi-colon separated, and spat,spec are in the
    # pseudo-image generated by COADD2D
    manual = None
# Par set to control sensitivity function computation.  Only used in the
# after-burner script.
[sensfunc]
    # Fraction of minimum wavelength coverage to grow the wavelength
    # coverage of the sensitivitity function in the blue direction, i.e.
    # if the standard star spectrumcuts off at wave_min, the sensfunc
    # will be extrapolated to cover down to  (1.0-extrap_blu)*wave_min
    extrap_blu = 0.1
    # Fraction of maximum wavelength coverage to grow the wavelength
    # coverage of the sensitivitity function in the red direction, i.e.
    # if the standard star spectrumcuts off at wave_max, the sensfunc
    # will be extrapolated to cover up to  (1.0 + extrap_red)*wave_max
    extrap_red = 0.1
    # sampling factor to make the wavelength grid for sensitivity
    # function finer or coarser.  samp_fact > 1.0 oversamples (finer),
    # samp_fact < 1.0 undersamples (coarser).
    samp_fact = 1.5
    # List of detectors (identified by their string name, like DET01) to
    # splice together for multi-detector instruments (e.g. DEIMOS). It
    # is assumed that there is *no* overlap in wavelength across
    # detectors (might be ok if there is).  If entered as a list of
    # integers, they should be converted to the detector name.  **Cannot
    # be used with detector mosaics.**
    multi_spec_det = None
    # Specify the algorithm for computing the sensitivity function. The
    # options are:  (1) UVIS = Should be used for data with lambda <
    # 7000A.No detailed model of telluric absorption but corrects for
    # atmospheric extinction. (2) IR = Should be used for data with
    # lambbda > 7000A.Peforms joint fit for sensitivity function and
    # telluric absorption using HITRAN models.
    algorithm = IR
    # Polynomial order for sensitivity function fitting
    polyorder = 9
    # Spectral type of the standard star (for near-IR mainly)
    star_type = None
    # Magnitude of the standard star (for near-IR mainly)
    star_mag = None
    # RA of the standard star. This will override values in the header,
    # i.e. if they are wrong or absent
    star_ra = None
    # DEC of the standard star. This will override values in the header,
    # i.e. if they are wrong or absent
    star_dec = None
    # Mask Balmer, Paschen, Brackett, and Pfund lines in sensitivity
    # function fit
    mask_abs_lines = True
    # Parameters for the UVIS sensfunc algorithm
    [[UVIS]]
        # Mask width for Balmer lines in Angstroms.
        balm_mask_wid = 10.0
        # Standard star file to generate sensfunc
        std_file = None
        # Specifies object in spec1d file to use as standard. The
        # brightest object found is used otherwise.
        std_obj_id = None
        # FITS file that contains or will contain the sensitivity
        # function.
        sensfunc = None
        # If extinct_correct=True the code will use an atmospheric
        # extinction model to extinction correct the data below 10000A.
        # Note that this correction makes no sense if one is telluric
        # correcting and this shold be set to False
        extinct_correct = True
        # If telluric_correct=True the code will grab the
        # sens_dict['telluric'] tag from the sensfunc dictionary and
        # apply it to the data.
        telluric_correct = False
        # If telluric=True the code creates a synthetic standard star
        # spectrum using the Kurucz models, the sens func is created
        # setting nresln=1.5 it contains the correction for telluric
        # lines.
        telluric = False
        # Whether you want to correct the sensfunc with polynomial in
        # the telluric and recombination line regions
        polycorrect = True
        # Whether you want to use the polynomial fit as your final
        # SENSFUNC
        polyfunc = False
        # Parameter governing the spacing of the bspline breakpoints.
        nresln = 20
        # Expected resolution of the standard star spectrum. This should
        # be measured from the data.
        resolution = 3000.0
        # Parameter for selecting telluric regions which are masked.
        # Locations below this transmission value are masked. If you
        # have significant telluric absorption you should be using
        # telluric.sensnfunc_telluric
        trans_thresh = 0.9
    # Parameters for the IR sensfunc algorithm
    [[IR]]
        # File containing the telluric grid for the observatory in
        # question. These grids are generated from HITRAN models for
        # each observatory using nominal site parameters. They must be
        # downloaded from the GoogleDrive and installed in your PypeIt
        # installation via the pypeit_install_telluric script. NOTE:
        # This parameter no longer includes the full pathname to the
        # Telluric Grid file, but is just the filename of the grid
        # itself.
        telgridfile = TelFit_MaunaKea_3100_26100_R20000.fits
        # This adds an error floor to the ivar, preventing too much
        # rejection at high-S/N (i.e. standard stars, bright objects)
        # using the function utils.clip_ivar. A small erorr is added to
        # the input ivar so that the output ivar_out will never give S/N
        # greater than sn_clip. This prevents overly aggressive
        # rejection in high S/N ratio spectra which neverthless differ
        # at a level greater than the formal S/N due to the fact that
        # our telluric models are only good to about 3%.
        sn_clip = 30.0
        # A guess for the resolution of your spectrum expressed as
        # lambda/dlambda. The resolution is fit explicitly as part of
        # the telluric model fitting, but this guess helps determine the
        # bounds for the optimization (see next). If not provided, the
        # wavelength sampling of your spectrum will be used and the
        # resolution calculated using a typical sampling of 3 spectral
        # pixels per resolution element.
        resln_guess = None
        # Bounds for the resolution fit optimization which is part of
        # the telluric model. This range is in units of the resln_guess,
        # so the (0.5, 1.5) would bound the spectral resolution fit to
        # be within the range bounds_resln = (0.5*resln_guess,
        # 1.5*resln_guess)
        resln_frac_bounds = (0.5, 1.5)
        #  Bounds for the pixel shift optimization in telluric model fit
        # in units of pixels. The atmosphere will be allowed to shift
        # within this range during the fit.
        pix_shift_bounds = (-5.0, 5.0)
        # Parameters setting the polynomial coefficient bounds for
        # sensfunc optimization.
        delta_coeff_bounds = (-20.0, 20.0)
        # Parameters setting the polynomial coefficient bounds for
        # sensfunc optimization.Bounds are currently determined as
        # follows. We compute an initial fit to the sensfunc in the
        # pypeit.core.telluric.init_sensfunc_model function. That
        # deterines a set of coefficients. The bounds are then
        # determined according to: [(np.fmin(np.abs(this_coeff)*obj_para
        # ms['delta_coeff_bounds'][0],
        # obj_params['minmax_coeff_bounds'][0]), np.fmax(np.abs(this_coe
        # ff)*obj_params['delta_coeff_bounds'][1],obj_params['minmax_coe
        # ff_bounds'][1]))]
        minmax_coeff_bounds = (-5.0, 5.0)
        # Maximum number of iterations for the telluric + object model
        # fitting. The code performs multiple iterations rejecting
        # outliers at each step. The fit is then performed anew to the
        # remaining good pixels. For this reason if you run with the
        # disp=True option, you will see that the f(x) loss function
        # gets progressively better during the iterations.
        maxiter = 2
        # Sticky parameter for the utils.djs_reject algorithm for
        # iterative model fit rejection.  If set to True then points
        # rejected from a previous iteration are kept rejected, in other
        # words the bad pixel mask is the OR of all previous iterations
        # and rejected pixels accumulate. If set to False, the bad pixel
        # mask is the mask from the previous iteration, and if the model
        # fit changes between iterations, points can alternate from
        # being rejected to not rejected. At present this code only
        # performs optimizations with differential evolution and
        # experience shows that sticky needs to be True in order for
        # these to converge. This is because the outliers can be so
        # large that they dominate the loss function, and one never
        # iteratively converges to a good model fit. In other words, the
        # deformations in the model between iterations with sticky=False
        # are too small to approach a reasonable fit.
        sticky = True
        # Lower rejection threshold in units of sigma_corr*sigma, where
        # sigma is the formal noise of the spectrum, and sigma_corr is
        # an empirically determined correction to the formal error. The
        # distribution of input chi (defined by chi = (data -
        # model)/sigma) values is analyzed, and a correction factor to
        # the formal error sigma_corr is returned which is multiplied
        # into the formal errors. In this way, a rejection threshold of
        # i.e. 3-sigma, will always correspond to roughly the same
        # percentile.  This renormalization is performed with
        # coadd1d.renormalize_errors function, and guarantees that
        # rejection is not too agressive in cases where the empirical
        # errors determined from the chi-distribution differ
        # significantly from the formal noise which is used to determine
        # chi.
        lower = 3.0
        # Upper rejection threshold in units of sigma_corr*sigma, where
        # sigma is the formal noise of the spectrum, and sigma_corr is
        # an empirically determined correction to the formal error. See
        # above for description.
        upper = 3.0
        # An initial seed for the differential evolution optimization,
        # which is a random process. The default is a seed = 777 which
        # will be used to generate a unique seed for every order. A
        # specific seed is used because otherwise the random number
        # generator will use the time for the seed, and the results will
        # not be reproducible.
        seed = 777
        # Relative tolerance for converage of the differential evolution
        # optimization. See scipy.optimize.differential_evolution for
        # details.
        tol = 0.001
        # A multiplier for setting the total population size for the
        # differential evolution optimization. See
        # scipy.optimize.differential_evolution for details.
        popsize = 30
        # The recombination constant for the differential evolution
        # optimization. This should be in the range [0, 1]. See
        # scipy.optimize.differential_evolution for details.
        recombination = 0.7
        # If True then differential evolution will perform an additional
        # optimizatino at the end to polish the best fit at the end,
        # which can improve the optimization slightly. See
        # scipy.optimize.differential_evolution for details.
        polish = True
        # Argument for scipy.optimize.differential_evolution which will
        # display status messages to the screen indicating the status of
        # the optimization. See documentation for telluric.Telluric for
        # a description of the output and how to know if things are
        # working well.
        disp = False
        # The object model to be used for telluric fitting. Currently
        # the options are: qso, star, and poly
        objmodel = None
        # The redshift for the object model. This is currently only used
        # by objmodel=qso
        redshift = 0.0
        # Range within the redshift can be varied for telluric fitting,
        # i.e. the code performs a bounded optimization withinthe
        # redshift +- delta_redshift
        delta_redshift = 0.1
        # Fits file containing quasar PCA model. Needed for
        # objmodel=qso.  NOTE: This parameter no longer includes the
        # full pathname to the Telluric Model file, but is just the
        # filename of the model itself.
        pca_file = qso_pca_1200_3100.fits
        # Number of pca for the objmodel=qso qso PCA fit
        npca = 8
        # Min/max wavelength of broad absorption features. If there are
        # several BAL features, the format for this mask is
        # [wave_min_bal1, wave_max_bal1,wave_min_bal2,
        # wave_max_bal2,...]. These masked pixels will be ignored during
        # the fitting.
        bal_wv_min_max = None
        # Normalization bounds for scaling the initial object model.
        bounds_norm = (0.1, 3.0)
        # Threshold of telluric absorption region
        tell_norm_thresh = 0.9
        # Order number, or list of order numbers if you only want to fit
        # specific orders
        only_orders = None
        # Minimum wavelength for the qso pca model
        pca_lower = 1220.0
        # Maximum wavelength for the qso pca model
        pca_upper = 3100.0
        # stellar type
        star_type = None
        # AB magnitude in V band
        star_mag = None
        # Object right-ascension in decimal deg
        star_ra = None
        # Object declination in decimal deg
        star_dec = None
        # Mask stellar absorption line?
        mask_abs_lines = True
        # Polynomial model function
        func = legendre
        # Types of polynomial model. Options are poly, square, exp
        # corresponding to normal polynomial,squared polynomial, or
        # exponentiated polynomial
        model = exp
        # Order of the polynomial model fit
        polyorder = 3
        # Pixels within this mask will be used during the fitting. The
        # formatis the same with bal_wv_min_max, but this mask is good
        # pixel masks.
        fit_wv_min_max = None
        # Mask the blueward of Lyman-alpha line during the fitting?
        mask_lyman_a = True
# Par set to control telluric fitting.  Only used in the pypeit_sensfunc
# and pypeit_telluric after-burner scripts.
[telluric]
    # File containing the telluric grid for the observatory in question.
    # These grids are generated from HITRAN models for each observatory
    # using nominal site parameters. They must be downloaded from the
    # GoogleDrive and installed in your PypeIt installation via the
    # pypeit_install_telluric script. NOTE: This parameter no longer
    # includes the full pathname to the Telluric Grid file, but is just
    # the filename of the grid itself.
    telgridfile = None
    # This adds an error floor to the ivar, preventing too much
    # rejection at high-S/N (i.e. standard stars, bright objects) using
    # the function utils.clip_ivar. A small erorr is added to the input
    # ivar so that the output ivar_out will never give S/N greater than
    # sn_clip. This prevents overly aggressive rejection in high S/N
    # ratio spectra which neverthless differ at a level greater than the
    # formal S/N due to the fact that our telluric models are only good
    # to about 3%.
    sn_clip = 30.0
    # A guess for the resolution of your spectrum expressed as
    # lambda/dlambda. The resolution is fit explicitly as part of the
    # telluric model fitting, but this guess helps determine the bounds
    # for the optimization (see next). If not provided, the  wavelength
    # sampling of your spectrum will be used and the resolution
    # calculated using a typical sampling of 3 spectral pixels per
    # resolution element.
    resln_guess = None
    # Bounds for the resolution fit optimization which is part of the
    # telluric model. This range is in units of the resln_guess, so the
    # (0.5, 1.5) would bound the spectral resolution fit to be within
    # the range bounds_resln = (0.5*resln_guess, 1.5*resln_guess)
    resln_frac_bounds = (0.5, 1.5)
    #  Bounds for the pixel shift optimization in telluric model fit in
    # units of pixels. The atmosphere will be allowed to shift within
    # this range during the fit.
    pix_shift_bounds = (-5.0, 5.0)
    # Parameters setting the polynomial coefficient bounds for sensfunc
    # optimization.
    delta_coeff_bounds = (-20.0, 20.0)
    # Parameters setting the polynomial coefficient bounds for sensfunc
    # optimization.Bounds are currently determined as follows. We
    # compute an initial fit to the sensfunc in the
    # pypeit.core.telluric.init_sensfunc_model function. That deterines
    # a set of coefficients. The bounds are then determined according
    # to:
    # [(np.fmin(np.abs(this_coeff)*obj_params['delta_coeff_bounds'][0],
    # obj_params['minmax_coeff_bounds'][0]), np.fmax(np.abs(this_coeff)*
    # obj_params['delta_coeff_bounds'][1],obj_params['minmax_coeff_bound
    # s'][1]))]
    minmax_coeff_bounds = (-5.0, 5.0)
    # Maximum number of iterations for the telluric + object model
    # fitting. The code performs multiple iterations rejecting outliers
    # at each step. The fit is then performed anew to the remaining good
    # pixels. For this reason if you run with the disp=True option, you
    # will see that the f(x) loss function gets progressively better
    # during the iterations.
    maxiter = 2
    # Sticky parameter for the utils.djs_reject algorithm for iterative
    # model fit rejection.  If set to True then points rejected from a
    # previous iteration are kept rejected, in other words the bad pixel
    # mask is the OR of all previous iterations and rejected pixels
    # accumulate. If set to False, the bad pixel mask is the mask from
    # the previous iteration, and if the model fit changes between
    # iterations, points can alternate from being rejected to not
    # rejected. At present this code only performs optimizations with
    # differential evolution and experience shows that sticky needs to
    # be True in order for these to converge. This is because the
    # outliers can be so large that they dominate the loss function, and
    # one never iteratively converges to a good model fit. In other
    # words, the deformations in the model between iterations with
    # sticky=False are too small to approach a reasonable fit.
    sticky = True
    # Lower rejection threshold in units of sigma_corr*sigma, where
    # sigma is the formal noise of the spectrum, and sigma_corr is an
    # empirically determined correction to the formal error. The
    # distribution of input chi (defined by chi = (data - model)/sigma)
    # values is analyzed, and a correction factor to the formal error
    # sigma_corr is returned which is multiplied into the formal errors.
    # In this way, a rejection threshold of i.e. 3-sigma, will always
    # correspond to roughly the same percentile.  This renormalization
    # is performed with coadd1d.renormalize_errors function, and
    # guarantees that rejection is not too agressive in cases where the
    # empirical errors determined from the chi-distribution differ
    # significantly from the formal noise which is used to determine
    # chi.
    lower = 3.0
    # Upper rejection threshold in units of sigma_corr*sigma, where
    # sigma is the formal noise of the spectrum, and sigma_corr is an
    # empirically determined correction to the formal error. See above
    # for description.
    upper = 3.0
    # An initial seed for the differential evolution optimization, which
    # is a random process. The default is a seed = 777 which will be
    # used to generate a unique seed for every order. A specific seed is
    # used because otherwise the random number generator will use the
    # time for the seed, and the results will not be reproducible.
    seed = 777
    # Relative tolerance for converage of the differential evolution
    # optimization. See scipy.optimize.differential_evolution for
    # details.
    tol = 0.001
    # A multiplier for setting the total population size for the
    # differential evolution optimization. See
    # scipy.optimize.differential_evolution for details.
    popsize = 30
    # The recombination constant for the differential evolution
    # optimization. This should be in the range [0, 1]. See
    # scipy.optimize.differential_evolution for details.
    recombination = 0.7
    # If True then differential evolution will perform an additional
    # optimizatino at the end to polish the best fit at the end, which
    # can improve the optimization slightly. See
    # scipy.optimize.differential_evolution for details.
    polish = True
    # Argument for scipy.optimize.differential_evolution which will
    # display status messages to the screen indicating the status of the
    # optimization. See documentation for telluric.Telluric for a
    # description of the output and how to know if things are working
    # well.
    disp = False
    # The object model to be used for telluric fitting. Currently the
    # options are: qso, star, and poly
    objmodel = None
    # The redshift for the object model. This is currently only used by
    # objmodel=qso
    redshift = 0.0
    # Range within the redshift can be varied for telluric fitting, i.e.
    # the code performs a bounded optimization withinthe redshift +-
    # delta_redshift
    delta_redshift = 0.1
    # Fits file containing quasar PCA model. Needed for objmodel=qso.
    # NOTE: This parameter no longer includes the full pathname to the
    # Telluric Model file, but is just the filename of the model itself.
    pca_file = qso_pca_1200_3100.fits
    # Number of pca for the objmodel=qso qso PCA fit
    npca = 8
    # Min/max wavelength of broad absorption features. If there are
    # several BAL features, the format for this mask is [wave_min_bal1,
    # wave_max_bal1,wave_min_bal2, wave_max_bal2,...]. These masked
    # pixels will be ignored during the fitting.
    bal_wv_min_max = None
    # Normalization bounds for scaling the initial object model.
    bounds_norm = (0.1, 3.0)
    # Threshold of telluric absorption region
    tell_norm_thresh = 0.9
    # Order number, or list of order numbers if you only want to fit
    # specific orders
    only_orders = None
    # Minimum wavelength for the qso pca model
    pca_lower = 1220.0
    # Maximum wavelength for the qso pca model
    pca_upper = 3100.0
    # stellar type
    star_type = None
    # AB magnitude in V band
    star_mag = None
    # Object right-ascension in decimal deg
    star_ra = None
    # Object declination in decimal deg
    star_dec = None
    # Mask stellar absorption line?
    mask_abs_lines = True
    # Polynomial model function
    func = legendre
    # Types of polynomial model. Options are poly, square, exp
    # corresponding to normal polynomial,squared polynomial, or
    # exponentiated polynomial
    model = exp
    # Order of the polynomial model fit
    polyorder = 3
    # Pixels within this mask will be used during the fitting. The
    # formatis the same with bal_wv_min_max, but this mask is good pixel
    # masks.
    fit_wv_min_max = None
    # Mask the blueward of Lyman-alpha line during the fitting?
    mask_lyman_a = True
# Par set to control collating 1d spectra.  Only used in the after-
# burner script.
[collate1d]
    # The tolerance used when comparing the coordinates of objects. If
    # two objects are within this distance from each other, they are
    # considered the same object. If match_using is 'ra/dec' (the
    # default) this is an angular distance. The defaults units are
    # arcseconds but other units supported by astropy.coordinates.Angle
    # can be used(e.g. '0.003d' or '0h1m30s'). If match_using is 'pixel'
    # this is a float.
    tolerance = 3.0
    # If set, the script will display the matching File and Object Ids
    # but will not flux, coadd or archive.
    dry_run = False
    # If set, the script will only coadd non-fluxed spectra even if flux
    # data is present. Otherwise fluxed spectra are coadded if all
    # spec1ds have been fluxed calibrated.
    ignore_flux = False
    # If set, the script will flux calibrate using archived sensfuncs
    # before coadding.
    flux = False
    # Determines how 1D spectra are matched as being the same object.
    # Must be either 'pixel' or 'ra/dec'.
    match_using = ra/dec
    # A list of slit trace bitmask bits that should be excluded.
    exclude_slit_trace_bm = []
    # Whether to exclude SERENDIP objects from collating.
    exclude_serendip = False
    # If set, any objects with a wavelength RMS > this value are
    # skipped, else all wavelength RMS values are accepted.
    wv_rms_thresh = None
    # The path where all coadded output files and report files will be
    # placed.
    outdir = /Volumes/Extreme SSD/highz_qso_arxiv/highz_qso_arxiv/arxiv/LRIS_2203/LRIS_220305/reduced/all_redo/J1355-0044